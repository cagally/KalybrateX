{
  "prompt": "I'm working on the Dify frontend and need to write Vitest tests for a workflow configuration component that uses React Testing Library. It has drag-and-drop functionality and context providers.",
  "baseline_response": "Here's a comprehensive example of how you might structure Vitest tests for a workflow configuration component with drag-and-drop functionality:\n\n```typescript\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\nimport { render, screen, fireEvent, act } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport React from 'react'\n\n// Import the component and any necessary context providers\nimport WorkflowConfiguration from './WorkflowConfiguration'\nimport { WorkflowProvider } from './WorkflowContext'\n\n// Mock any external dependencies\nvi.mock('./some-external-dependency', () => ({\n  someFunction: vi.fn()\n}))\n\ndescribe('WorkflowConfiguration Component', () => {\n  // Setup function to wrap the component with necessary providers\n  const renderComponent = (props = {}) => {\n    return render(\n      <WorkflowProvider>\n        <WorkflowConfiguration {...props} />\n      </WorkflowProvider>\n    )\n  }\n\n  // Test initial rendering\n  it('renders the workflow configuration correctly', () => {\n    renderComponent()\n    \n    // Check for key elements\n    expect(screen.getByTestId('workflow-config-container')).toBeInTheDocument()\n    expect(screen.getByText('Workflow Configuration')).toBeInTheDocument()\n  })\n\n  // Test drag and drop functionality\n  it('handles drag and drop of workflow nodes', async () => {\n    const user = userEvent.setup()\n    renderComponent()\n\n    // Find draggable and droppable elements\n    const draggableNode = screen.getByTestId('draggable-node')\n    const dropZone = screen.getByTestId('drop-zone')\n\n    // Simulate drag and drop\n    await act(async () => {\n      // Use fireEvent for more low-level drag and drop simulation\n      fireEvent.dragStart(draggableNode)\n      fireEvent.dragEnter(dropZone)\n      fireEvent.drop(dropZone)\n    })\n\n    // Assert the expected outcome\n    expect(screen.getByTestId('dropped-node')).toBeInTheDocument()\n  })\n\n  // Test adding a new workflow node\n  it('allows adding a new workflow node', async () => {\n    const user = userEvent.setup()\n    renderComponent()\n\n    // Find add node button\n    const addNodeButton = screen.getByTestId('add-node-button')\n\n    // Click to add node\n    await user.click(addNodeButton)\n\n    // Check if new node is added\n    expect(screen.getByTestId('workflow-node')).toBeInTheDocument()\n  })\n\n  // Test configuration updates\n  it('updates workflow configuration correctly', async () => {\n    const user = userEvent.setup()\n    const mockOnConfigUpdate = vi.fn()\n    renderComponent({ onConfigUpdate: mockOnConfigUpdate })\n\n    // Find configuration input\n    const configInput = screen.getByTestId('workflow-config-input')\n\n    // Simulate user input\n    await user.type(configInput, 'New Configuration')\n\n    // Check if update callback is called\n    expect(mockOnConfigUpdate).toHaveBeenCalledWith(expect.stringContaining('New Configuration'))\n  })\n\n  // Test error handling\n  it('displays error state when configuration is invalid', () => {\n    renderComponent()\n\n    // Trigger an invalid configuration\n    const invalidConfigButton = screen.getByTestId('invalid-config-button')\n    fireEvent.click(invalidConfigButton)\n\n    // Check for error message\n    expect(screen.getByTestId('error-message')).toBeInTheDocument()\n  })\n\n  // Accessibility tests\n  it('maintains proper keyboard navigation', async () => {\n    const user = userEvent.setup()\n    renderComponent()\n\n    const firstNode = screen.getByTestId('workflow-node-1')\n    \n    // Simulate keyboard navigation\n    await user.tab()\n    await user.keyboard('[Enter]')\n\n    // Assert focus and selection\n    expect(firstNode).toHaveFocus()\n  })\n})\n```\n\nKey Testing Strategies:\n\n1. **Providers Wrapping**: Use a custom render function that wraps the component with necessary context providers.\n\n2. **Drag and Drop Testing**:\n   - Use `fireEvent` for low-level drag and drop simulations\n   - Wrap drag and drop interactions in `act()` to handle async updates\n\n3. **User Interactions**:\n   - Utilize `userEvent` for more natural user interaction simulations\n   - Test keyboard and click interactions\n\n4. **Mock Dependencies**:\n   - Use `vi.mock()` to mock external dependencies\n   - Create mock functions for callbacks and event handlers\n\nRecommended Test Coverage:\n- Initial rendering\n- Drag and drop functionality\n- Adding/removing workflow nodes\n- Configuration updates\n- Error handling\n- Accessibility considerations\n\nAdditional Considerations:\n- Add `data-testid` attributes to key elements for easier selection\n- Use meaningful test descriptions\n- Cover different scenarios and edge cases\n\nTesting Setup Tips:\n```typescript\n// In your vitest.config.ts\nimport { defineConfig } from 'vitest/config'\nimport react from '@vitejs/plugin-react'\n\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    globals: true,\n    environment: 'jsdom',\n    setupFiles: ['./src/test/setup.ts'],\n  }\n})\n```\n\nThis example provides a comprehensive approach to testing a complex workflow configuration component with various interaction scenarios.",
  "skill_response": "I'll help you generate comprehensive Vitest tests for the workflow configuration component. I'll provide a detailed test structure that covers rendering, interactions, edge cases, and drag-and-drop functionality.\n\n```typescript\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { DndProvider } from 'react-dnd'\nimport { HTML5Backend } from 'react-dnd-html5-backend'\nimport WorkflowConfiguration from './WorkflowConfiguration'\nimport { WorkflowContext } from '@/context/workflow-context'\n\n// Mock dependencies\nvi.mock('@/context/workflow-context')\nvi.mock('@/services/workflow-api')\n\n// Sample mock data\nconst mockWorkflowNodes = [\n  { id: '1', type: 'start', name: 'Start Node' },\n  { id: '2', type: 'llm', name: 'LLM Node' },\n]\n\ndescribe('WorkflowConfiguration', () => {\n  const mockContextValue = {\n    nodes: mockWorkflowNodes,\n    addNode: vi.fn(),\n    updateNode: vi.fn(),\n    deleteNode: vi.fn(),\n  }\n\n  const renderComponent = (props = {}) => {\n    return render(\n      <DndProvider backend={HTML5Backend}>\n        <WorkflowContext.Provider value={mockContextValue}>\n          <WorkflowConfiguration {...props} />\n        </WorkflowContext.Provider>\n      </DndProvider>\n    )\n  }\n\n  // Rendering Tests\n  describe('Rendering', () => {\n    it('should render without crashing', () => {\n      renderComponent()\n      expect(screen.getByTestId('workflow-configuration')).toBeInTheDocument()\n    })\n\n    it('should display workflow nodes', () => {\n      renderComponent()\n      expect(screen.getByText('Start Node')).toBeInTheDocument()\n      expect(screen.getByText('LLM Node')).toBeInTheDocument()\n    })\n  })\n\n  // Drag and Drop Tests\n  describe('Drag and Drop Functionality', () => {\n    it('should allow dragging nodes', async () => {\n      const user = userEvent.setup()\n      renderComponent()\n\n      const startNode = screen.getByText('Start Node')\n      const dropZone = screen.getByTestId('workflow-drop-zone')\n\n      // Simulate drag and drop\n      await user.drag(startNode, {\n        target: dropZone,\n        delta: { x: 100, y: 100 }\n      })\n\n      // Verify node was moved/added\n      expect(mockContextValue.addNode).toHaveBeenCalled()\n    })\n\n    it('should prevent invalid node drops', async () => {\n      const user = userEvent.setup()\n      renderComponent()\n\n      const invalidNode = screen.getByText('Invalid Node')\n      const dropZone = screen.getByTestId('workflow-drop-zone')\n\n      // Attempt to drop invalid node\n      await user.drag(invalidNode, {\n        target: dropZone,\n        delta: { x: 100, y: 100 }\n      })\n\n      // Verify no node was added\n      expect(mockContextValue.addNode).not.toHaveBeenCalled()\n    })\n  })\n\n  // Node Configuration Tests\n  describe('Node Configuration', () => {\n    it('should open node configuration modal on click', async () => {\n      const user = userEvent.setup()\n      renderComponent()\n\n      const nodeToConfig = screen.getByText('LLM Node')\n      await user.click(nodeToConfig)\n\n      // Verify configuration modal opens\n      expect(screen.getByTestId('node-configuration-modal')).toBeInTheDocument()\n    })\n\n    it('should update node configuration', async () => {\n      const user = userEvent.setup()\n      renderComponent()\n\n      const nodeToConfig = screen.getByText('LLM Node')\n      await user.click(nodeToConfig)\n\n      // Fill configuration inputs\n      const nameInput = screen.getByLabelText('Node Name')\n      await user.type(nameInput, 'Updated LLM Node')\n\n      const saveButton = screen.getByText('Save Configuration')\n      await user.click(saveButton)\n\n      // Verify node was updated\n      expect(mockContextValue.updateNode).toHaveBeenCalledWith(\n        expect.objectContaining({ name: 'Updated LLM Node' })\n      )\n    })\n  })\n\n  // Edge Cases\n  describe('Edge Cases', () => {\n    it('should handle empty workflow state', () => {\n      const emptyContextValue = {\n        ...mockContextValue,\n        nodes: [],\n      }\n\n      render(\n        <DndProvider backend={HTML5Backend}>\n          <WorkflowContext.Provider value={emptyContextValue}>\n            <WorkflowConfiguration />\n          </WorkflowContext.Provider>\n        </DndProvider>\n      )\n\n      // Verify empty state message\n      expect(screen.getByText(/no workflow nodes/i)).toBeInTheDocument()\n    })\n\n    it('should limit maximum number of nodes', async () => {\n      const user = userEvent.setup()\n      renderComponent({ maxNodes: 2 })\n\n      const dropZone = screen.getByTestId('workflow-drop-zone')\n      const additionalNode = screen.getByText('Additional Node')\n\n      // Attempt to add more nodes than allowed\n      await user.drag(additionalNode, {\n        target: dropZone,\n        delta: { x: 100, y: 100 }\n      })\n\n      // Verify node limit error\n      expect(screen.getByText(/maximum nodes reached/i)).toBeInTheDocument()\n      expect(mockContextValue.addNode).not.toHaveBeenCalled()\n    })\n  })\n\n  // Accessibility Tests\n  describe('Accessibility', () => {\n    it('should support keyboard navigation', async () => {\n      const user = userEvent.setup()\n      renderComponent()\n\n      const firstNode = screen.getByText('Start Node')\n      await user.tab()\n      await user.keyboard('[Enter]')\n\n      // Verify node is focused/selected\n      expect(firstNode).toHaveFocus()\n    })\n  })\n})\n```\n\n### Key Testing Strategies Used\n\n1. **Context Mocking**: Simulate WorkflowContext with mock functions\n2. **Drag and Drop Testing**: Use `userEvent.drag()` for interaction simulation\n3. **Comprehensive Coverage**:\n   - Rendering tests\n   - Drag and drop functionality\n   - Node configuration\n   - Edge cases (empty state, node limits)\n   - Accessibility considerations\n\n### Recommended Setup\n\nEnsure you have these dependencies:\n```bash\npnpm add -D @testing-library/react @testing-library/user-event @testing-library/jest-dom \npnpm add react-dnd react-dnd-html5-backend\n```\n\n### Additional Recommendations\n\n1. Add `data-testid` attributes in your actual component\n2. Implement proper error handling in drag and drop\n3. Create a custom render function for consistent context wrapping\n4. Use TypeScript for better type safety\n\n### Next Steps\n\n1. Adjust the test based on your actual component implementation\n2. Run with `pnpm test:watch`\n3. Verify coverage with `pnpm test:coverage`\n\nWould you like me to elaborate on any part of the test suite or discuss specific implementation details for your workflow configuration component?",
  "verdict": "skill",
  "reasoning": "Response B is superior in several key areas. It provides more accurate drag-and-drop testing using userEvent.drag() which is the modern approach, while Response A uses the less reliable fireEvent for drag operations. Response B includes proper DndProvider setup which is essential for testing drag-and-drop components. The test structure in B is more comprehensive with better organized describe blocks covering rendering, drag-and-drop, node configuration, edge cases, and accessibility. Response B also includes more practical edge case testing like empty states and node limits, and provides actionable next steps with specific commands and recommendations. The code examples in B are more realistic and closer to actual Dify frontend patterns, while Response A's examples are more generic. Overall, Response B offers better accuracy, completeness, and practical value for testing a workflow configuration component.",
  "baseline_tokens": 1359,
  "skill_tokens": 4684,
  "position_a": "baseline",
  "position_b": "skill",
  "judge_model": "claude-sonnet-4-20250514",
  "judged_at": "2026-01-11T16:55:33.765123Z"
}