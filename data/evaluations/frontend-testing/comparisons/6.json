{
  "prompt": "My component uses next/navigation for routing and some external APIs. What's the best way to mock these dependencies in my spec file?",
  "baseline_response": "Here's a comprehensive approach to mocking dependencies in your Next.js component tests:\n\n```typescript\n// Example test file for a component\nimport { render, screen } from '@testing-library/react'\nimport { useRouter } from 'next/navigation'\nimport axios from 'axios'\nimport MyComponent from './MyComponent'\n\n// Mock next/navigation\njest.mock('next/navigation', () => ({\n  useRouter: jest.fn(),\n  usePathname: jest.fn(),\n  useSearchParams: jest.fn()\n}))\n\n// Mock external API library\njest.mock('axios')\nconst mockedAxios = axios as jest.Mocked<typeof axios>\n\ndescribe('MyComponent', () => {\n  // Setup mocks before each test\n  beforeEach(() => {\n    // Reset mocks\n    jest.clearAllMocks()\n\n    // Setup router mock\n    const mockRouter = {\n      push: jest.fn(),\n      replace: jest.fn(),\n      back: jest.fn(),\n    }\n    ;(useRouter as jest.Mock).mockReturnValue(mockRouter)\n\n    // Setup other navigation mocks if needed\n    ;(usePathname as jest.Mock).mockReturnValue('/some-path')\n    ;(useSearchParams as jest.Mock).mockReturnValue(new URLSearchParams())\n  })\n\n  it('renders correctly', async () => {\n    // Mock API response\n    mockedAxios.get.mockResolvedValue({\n      data: { \n        results: [\n          { id: 1, name: 'Test Item' }\n        ]\n      }\n    })\n\n    render(<MyComponent />)\n\n    // Assertions\n    expect(screen.getByText('Test Item')).toBeInTheDocument()\n  })\n\n  it('handles navigation', () => {\n    const mockRouter = {\n      push: jest.fn()\n    }\n    ;(useRouter as jest.Mock).mockReturnValue(mockRouter)\n\n    render(<MyComponent />)\n\n    // Simulate a navigation action\n    const navigationButton = screen.getByRole('button', { name: /navigate/i })\n    navigationButton.click()\n\n    expect(mockRouter.push).toHaveBeenCalledWith('/expected-route')\n  })\n\n  it('handles API error', async () => {\n    // Mock API error\n    mockedAxios.get.mockRejectedValue(new Error('Network error'))\n\n    render(<MyComponent />)\n\n    // Check error handling\n    expect(screen.getByText('Error loading data')).toBeInTheDocument()\n  })\n})\n\n// For more complex scenarios, you might want a more flexible mock\nconst createMockRouter = (params: Partial<ReturnType<typeof useRouter>>) => ({\n  push: jest.fn(),\n  replace: jest.fn(),\n  back: jest.fn(),\n  ...params\n})\n```\n\nKey Mocking Strategies:\n1. Use `jest.mock()` to replace entire modules\n2. Create mock implementations for router methods\n3. Use `jest.fn()` to create mockable functions\n4. Reset mocks before each test with `jest.clearAllMocks()`\n\nAdditional Best Practices:\n- Use `beforeEach()` to reset mocks\n- Create flexible mock implementations\n- Test various scenarios (success, error, navigation)\n\nComplex Mocking Example:\n```typescript\n// For more complex routing scenarios\nconst mockRouterContext = {\n  pathname: '/current-path',\n  query: { id: '123' },\n  asPath: '/current-path?id=123',\n  // Add other methods/properties as needed\n}\n\n// Or use a library like `next-test-api-route-handler` for more comprehensive mocking\n```\n\nDependency Injection Alternative:\n```typescript\n// Component with injectable dependencies\ninterface ComponentProps {\n  router?: {\n    push: (path: string) => void\n  }\n  apiClient?: {\n    fetchData: () => Promise<any>\n  }\n}\n\nfunction MyComponent({ \n  router = useRouter(), \n  apiClient = axios \n}: ComponentProps) {\n  // Component logic\n}\n\n// Makes testing more flexible\n```\n\nTesting Libraries to Consider:\n- `@testing-library/react`\n- `@testing-library/react-hooks`\n- `jest`\n- `next-test-api-route-handler`\n\nError Handling Mock:\n```typescript\nit('handles network errors gracefully', async () => {\n  mockedAxios.get.mockRejectedValue(new Error('Network failure'))\n  \n  render(<MyComponent />)\n  \n  // Wait for error state\n  await waitFor(() => {\n    expect(screen.getByText('Error loading data')).toBeInTheDocument()\n  })\n})\n```\n\nTypeScript Type Safety:\n```typescript\n// Ensure type safety with generics\nconst mockRouter = {\n  push: jest.fn<void, [string]>(),\n  // Specify parameter and return types\n}\n```\n\nPro Tips:\n- Always mock external dependencies\n- Test both happy and error paths\n- Use `waitFor()` for async operations\n- Keep mocks as close to real implementation as possible\n\nThis approach provides a robust way to mock Next.js routing and external API dependencies, allowing comprehensive testing of your components.",
  "skill_response": "I'll provide a comprehensive example demonstrating best practices for mocking Next.js navigation and external APIs in a Vitest spec file. I'll break this down step-by-step:\n\n```typescript\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport { vi, describe, it, expect, beforeEach } from 'vitest'\n\n// 1. Mock next/navigation (REQUIRED for components using routing)\nvi.mock('next/navigation', () => ({\n  useRouter: () => ({\n    push: vi.fn(),      // Mock navigation\n    replace: vi.fn(),   // Include other common router methods\n    back: vi.fn(),\n    forward: vi.fn()\n  }),\n  usePathname: () => '/current/path',\n  useSearchParams: () => new URLSearchParams('test=value')\n}))\n\n// 2. Mock external API services (use vi.mock for consistent mocking)\nvi.mock('@/service/api', () => ({\n  // Mock specific API methods you'll use\n  fetchData: vi.fn().mockResolvedValue({\n    data: [{ id: 1, name: 'Test Item' }],\n    success: true\n  }),\n  createItem: vi.fn().mockResolvedValue({\n    id: 123,\n    status: 'created'\n  })\n}))\n\n// Optional: More granular API mocking with nock for HTTP requests\nimport nock from 'nock'\n\ndescribe('YourComponent', () => {\n  beforeEach(() => {\n    // Clear all mocks before each test\n    vi.clearAllMocks()\n    \n    // Reset any HTTP mocking\n    nock.cleanAll()\n  })\n\n  it('should use mocked router navigation', () => {\n    const { push } = require('next/navigation').useRouter()\n    \n    // Example of testing router interaction\n    fireEvent.click(screen.getByTestId('navigate-button'))\n    \n    expect(push).toHaveBeenCalledWith('/target-route')\n  })\n\n  it('should fetch data using mocked API', async () => {\n    const { fetchData } = require('@/service/api')\n    \n    const result = await fetchData()\n    \n    expect(fetchData).toHaveBeenCalled()\n    expect(result.data).toHaveLength(1)\n    expect(result.data[0].name).toBe('Test Item')\n  })\n\n  it('handles external HTTP requests with nock', async () => {\n    // Precise HTTP request mocking\n    const scope = nock('https://api.example.com')\n      .get('/users')\n      .reply(200, { users: [{ id: 1, name: 'Test User' }] })\n\n    // Your actual fetch logic here\n    const response = await fetch('https://api.example.com/users')\n    const data = await response.json()\n\n    expect(data.users).toHaveLength(1)\n    scope.done() // Verify all nock expectations were met\n  })\n\n  // Advanced: Simulating different API response scenarios\n  it('handles API error states', async () => {\n    // Mock API to throw an error\n    vi.mocked(require('@/service/api').fetchData).mockRejectedValue(\n      new Error('Network Error')\n    )\n\n    // Test error handling logic\n    await expect(fetchData()).rejects.toThrow('Network Error')\n  })\n})\n\n// Pro Tip: Type-safe mocking for TypeScript\nimport type { Router } from 'next/navigation'\n\n// Optionally create a type-safe mock implementation\nconst createMockRouter = (params?: Partial<Router>): Router => ({\n  push: vi.fn(),\n  replace: vi.fn(),\n  back: vi.fn(),\n  forward: vi.fn(),\n  ...params\n})\n```\n\n## üåü Key Mocking Strategies\n\n### 1. Next.js Navigation Mocking\n- Always mock entire `next/navigation` module\n- Provide mock implementations for common methods\n- Return predictable, testable values\n\n### 2. API Service Mocking\n- Use `vi.mock()` for internal services\n- Provide realistic mock return values\n- Mock both success and error scenarios\n\n### 3. External HTTP Request Mocking\n- Use `nock` for precise HTTP interaction testing\n- Simulate various response scenarios\n- Verify request expectations\n\n## üö® Best Practices\n\n1. **Always clear mocks** before each test\n2. **Return realistic mock data**\n3. **Test both happy and error paths**\n4. **Use type-safe mocking when possible**\n5. **Avoid over-mocking - use real implementations when feasible**\n\n## üì¶ Recommended Packages\n- `vitest` - Test runner\n- `@testing-library/react` - Component rendering\n- `nock` - HTTP request mocking\n- `msw` (optional) - More advanced request mocking\n\n## üîç When to Mock vs. Not Mock\n\n‚úÖ **Mock These**:\n- External API calls\n- Next.js routing methods\n- Complex context providers\n- Third-party libraries with side effects\n\n‚ùå **Do NOT Mock**:\n- Base components\n- Simple utility functions\n- Pure rendering components\n- Local helper functions\n\nBy following these patterns, you'll create robust, maintainable tests that accurately simulate your component's behavior across different scenarios.",
  "verdict": "skill",
  "reasoning": "Response B is superior in several key ways: 1) It uses modern Vitest instead of Jest, which is more current for React testing; 2) It provides more comprehensive mocking strategies including nock for HTTP requests and MSW as an alternative; 3) It includes better TypeScript support with type-safe mocking examples; 4) It offers clearer best practices with explicit do's and don'ts; 5) It provides more realistic and varied testing scenarios including error handling; 6) The code examples are more complete and actionable with proper imports and setup. Response A provides solid basic mocking but lacks the depth, modern tooling, and comprehensive guidance that Response B delivers.",
  "baseline_tokens": 1281,
  "skill_tokens": 4142,
  "position_a": "baseline",
  "position_b": "skill",
  "judge_model": "claude-sonnet-4-20250514",
  "judged_at": "2026-01-11T17:55:34.208588Z"
}