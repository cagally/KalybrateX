{
  "prompt": "Can you show me how to set up input validation for my MCP tools using TypeScript? I want to make sure the parameters are properly validated before calling the external API.",
  "baseline_response": "Here's an example of how you can implement input validation for MCP tools using TypeScript with a combination of interfaces, validation libraries, and error handling:\n\n```typescript\nimport { z } from 'zod'; // Recommended validation library\nimport axios from 'axios'; // HTTP client\n\n// Define an interface for the input parameters\ninterface McpToolParams {\n  toolId: string;\n  action: string;\n  parameters: Record<string, unknown>;\n}\n\n// Create a Zod schema for validation\nconst McpToolParamsSchema = z.object({\n  toolId: z.string().min(1, { message: \"Tool ID must not be empty\" })\n    .max(50, { message: \"Tool ID is too long\" }),\n  action: z.string().min(1, { message: \"Action must be specified\" })\n    .refine(value => ['create', 'update', 'delete'].includes(value), {\n      message: \"Invalid action type\"\n    }),\n  parameters: z.record(z.unknown()).optional()\n});\n\n// Validation function\nfunction validateMcpToolParams(params: McpToolParams): McpToolParams {\n  try {\n    // Validate the input against the schema\n    const validatedParams = McpToolParamsSchema.parse(params);\n    return validatedParams;\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      // Format validation errors\n      const formattedErrors = error.errors.map(err => ({\n        path: err.path.join('.'),\n        message: err.message\n      }));\n\n      // Throw a custom validation error\n      throw new ValidationError('Invalid MCP tool parameters', formattedErrors);\n    }\n    throw error;\n  }\n}\n\n// Custom validation error class\nclass ValidationError extends Error {\n  public details: Array<{ path: string; message: string }>;\n\n  constructor(\n    message: string, \n    details: Array<{ path: string; message: string }>\n  ) {\n    super(message);\n    this.name = 'ValidationError';\n    this.details = details;\n  }\n}\n\n// MCP Tool Service\nclass McpToolService {\n  private apiBaseUrl: string;\n\n  constructor(apiBaseUrl: string) {\n    this.apiBaseUrl = apiBaseUrl;\n  }\n\n  // Method to execute MCP tool with input validation\n  async executeTool(params: McpToolParams): Promise<any> {\n    try {\n      // Validate input parameters\n      const validatedParams = validateMcpToolParams(params);\n\n      // Additional custom validation if needed\n      this.additionalCustomValidation(validatedParams);\n\n      // Call external API\n      const response = await axios.post(`${this.apiBaseUrl}/tools`, validatedParams);\n      return response.data;\n    } catch (error) {\n      // Handle different types of errors\n      if (error instanceof ValidationError) {\n        console.error('Validation Failed:', error.details);\n        throw error;\n      } else if (error instanceof axios.AxiosError) {\n        // Handle API-specific errors\n        throw new Error(`API Error: ${error.message}`);\n      }\n      throw error;\n    }\n  }\n\n  // Example of additional custom validation\n  private additionalCustomValidation(params: McpToolParams): void {\n    // Custom business logic validation\n    if (params.action === 'delete' && !params.parameters?.force) {\n      throw new ValidationError('Deletion requires force parameter', [\n        { \n          path: 'parameters.force', \n          message: 'Force parameter must be provided for deletion' \n        }\n      ]);\n    }\n  }\n}\n\n// Example usage\nasync function example() {\n  const mcpToolService = new McpToolService('https://api.example.com');\n\n  try {\n    // Valid input\n    const result = await mcpToolService.executeTool({\n      toolId: 'tool-123',\n      action: 'create',\n      parameters: { name: 'New Tool' }\n    });\n    console.log(result);\n\n    // This would throw a validation error\n    await mcpToolService.executeTool({\n      toolId: '', // Empty tool ID\n      action: 'invalid-action',\n      parameters: {}\n    });\n  } catch (error) {\n    if (error instanceof ValidationError) {\n      console.error('Validation Errors:', error.details);\n    } else {\n      console.error('Unexpected Error:', error);\n    }\n  }\n}\n\n// Run the example\nexample();\n```\n\nKey features of this validation approach:\n\n1. **Zod Schema Validation**\n   - Uses Zod for type-safe and comprehensive input validation\n   - Defines strict rules for input parameters\n   - Provides detailed error messages\n\n2. **Custom Validation Error**\n   - Creates a custom `ValidationError` class\n   - Captures detailed validation error information\n   - Allows for granular error handling\n\n3. **Flexible Validation Process**\n   - Validates basic structure and types\n   - Allows for additional custom validation logic\n   - Supports both schema-based and custom business rules\n\n4. **Error Handling**\n   - Catches and processes different types of errors\n   - Provides meaningful error messages\n   - Separates validation errors from other types of errors\n\n5. **Typescript Typing**\n   - Uses interfaces and type checking\n   - Provides type safety throughout the validation process\n\nDependencies you'll need to install:\n```bash\nnpm install zod axios\nnpm install -D @types/node\n```\n\nThis approach provides a robust, flexible, and type-safe method of validating input for MCP tools before making API calls. You can easily extend the validation rules, add more custom checks, and handle various error scenarios.\n\nRecommendations for further improvement:\n- Add more specific validation rules based on your exact use case\n- Implement logging for validation errors\n- Create more granular error types if needed\n- Consider adding input sanitization if required",
  "skill_response": "I'll provide a comprehensive example of input validation for MCP tools using TypeScript with Zod, which is excellent for creating robust input schemas. Here's a detailed walkthrough:\n\n```typescript\nimport { z } from 'zod';\nimport { McpTool } from '@modelcontextprotocol/typescript-sdk';\n\n// Example: GitHub Repository Creation Tool\nexport class GitHubRepoCreationTool implements McpTool {\n  // Input schema definition using Zod\n  static inputSchema = z.object({\n    name: z.string()\n      .min(3, { message: \"Repository name must be at least 3 characters\" })\n      .max(100, { message: \"Repository name cannot exceed 100 characters\" })\n      .regex(/^[a-z0-9-]+$/i, { \n        message: \"Repository name can only contain alphanumeric characters and hyphens\" \n      }),\n    \n    description: z.string()\n      .optional()\n      .max(250, { message: \"Description cannot exceed 250 characters\" }),\n    \n    visibility: z.enum(['public', 'private'], {\n      errorMap: () => ({ \n        message: \"Visibility must be either 'public' or 'private'\" \n      })\n    }).default('public'),\n    \n    // Example of a more complex validation\n    topics: z.array(z.string())\n      .optional()\n      .transform(topics => topics?.slice(0, 5)) // Limit to 5 topics\n      .refine(topics => \n        topics ? topics.every(topic => /^[a-z0-9-]+$/i.test(topic)) : true,\n        { message: \"Topics can only contain alphanumeric characters and hyphens\" }\n  });\n\n  // Tool metadata\n  static metadata = {\n    name: 'github_create_repo',\n    description: 'Create a new GitHub repository',\n    readOnlyHint: false,\n    destructiveHint: true\n  };\n\n  // Main tool implementation\n  async execute(input: unknown) {\n    // Validate input using the defined schema\n    const validatedInput = await GitHubRepoCreationTool.inputSchema.parseAsync(input);\n\n    try {\n      // Perform actual API call with validated input\n      const response = await this.createRepositoryInGitHub(validatedInput);\n      \n      return {\n        text: `Successfully created repository: ${validatedInput.name}`,\n        structuredContent: response\n      };\n    } catch (error) {\n      // Enhanced error handling\n      throw new Error(`Repository creation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  // Simulated GitHub API method (replace with actual implementation)\n  private async createRepositoryInGitHub(input: z.infer<typeof GitHubRepoCreationTool.inputSchema>) {\n    // Actual GitHub API call would go here\n    return {\n      id: 'repo-123',\n      name: input.name,\n      visibility: input.visibility\n    };\n  }\n}\n\n// Example usage and error handling demonstration\nasync function demonstrateValidation() {\n  const tool = new GitHubRepoCreationTool();\n\n  // Valid input\n  try {\n    const validResult = await tool.execute({\n      name: 'my-awesome-project',\n      description: 'A fantastic new project',\n      visibility: 'public',\n      topics: ['typescript', 'github']\n    });\n    console.log('Valid input:', validResult);\n  } catch (error) {\n    console.error('Unexpected error with valid input', error);\n  }\n\n  // Invalid inputs to show validation\n  const invalidInputs = [\n    { name: 'ab' }, // Too short\n    { name: 'Very Long Repository Name That Exceeds The Maximum Allowed Length' }, // Too long\n    { name: 'Invalid Repo Name!' }, // Invalid characters\n    { visibility: 'secret' } // Invalid visibility\n  ];\n\n  for (const invalidInput of invalidInputs) {\n    try {\n      await tool.execute(invalidInput);\n    } catch (error) {\n      console.error('Validation caught invalid input:', error);\n    }\n  }\n}\n\n// Advanced: Custom validation example\nexport class AdvancedValidationTool implements McpTool {\n  static inputSchema = z.object({\n    // Complex nested validation\n    user: z.object({\n      id: z.string().uuid('User ID must be a valid UUID'),\n      email: z.string().email('Invalid email format'),\n      age: z.number().int().min(18, 'User must be at least 18 years old').max(120, 'Invalid age')\n    }),\n\n    // Conditional validation\n    subscription: z.discriminatedUnion('type', [\n      z.object({\n        type: z.literal('free'),\n        maxProjects: z.number().int().max(3)\n      }),\n      z.object({\n        type: z.literal('pro'),\n        maxProjects: z.number().int().min(10).max(100)\n      })\n    ])\n  }).refine(\n    // Cross-field validation\n    (data) => {\n      if (data.subscription.type === 'free' && data.user.age > 65) {\n        return false; // Custom logic: seniors can't have free tier\n      }\n      return true;\n    },\n    { message: 'Senior users are not eligible for free subscription' }\n  );\n\n  // Implement execute method similarly to previous example\n}\n```\n\nKey Validation Techniques Demonstrated:\n\n1. **Basic Validations**\n   - String length constraints\n   - Regex pattern matching\n   - Enum validation\n   - Optional fields\n   - Default values\n\n2. **Advanced Validations**\n   - Array transformations\n   - Complex nested object validation\n   - Discriminated unions\n   - Cross-field validations\n\n3. **Error Handling**\n   - Detailed error messages\n   - Consistent error throwing\n   - Type-safe input parsing\n\n4. **MCP Tool Best Practices**\n   - Metadata definition\n   - Structured return types\n   - Read/write hints\n\nRecommendations:\n- Use Zod for type-safe, declarative validation\n- Always validate inputs before API calls\n- Provide clear, actionable error messages\n- Use type inference to maintain type safety\n- Add comprehensive validation beyond basic type checking\n\nTo use this in your MCP server:\n1. Install Zod: `npm install zod`\n2. Import and use the validation schemas\n3. Implement tool-specific logic\n4. Register tools with your MCP server\n\nThe example shows how to create robust, type-safe input validation that goes far beyond simple type checking, ensuring your MCP tools are secure and predictable.",
  "verdict": "skill",
  "reasoning": "Response A is significantly better because it provides MCP-specific implementation with proper MCP tool interfaces, metadata definitions, and best practices. It shows actual MCP tool class structure with proper execute methods, tool metadata, and MCP-specific patterns. Response A also demonstrates more sophisticated validation techniques including discriminated unions, cross-field validation, and array transformations. The code is more comprehensive and production-ready. Response B, while showing good general TypeScript validation patterns, uses generic interfaces and axios calls that don't align with actual MCP tool development patterns. Response A directly addresses the user's need for MCP tool validation with accurate, MCP-specific TypeScript implementation.",
  "baseline_tokens": 1463,
  "skill_tokens": 3908,
  "position_a": "skill",
  "position_b": "baseline",
  "judge_model": "claude-sonnet-4-20250514",
  "judged_at": "2026-01-11T18:16:01.681527Z"
}