{
  "prompt": "I have a component that makes API calls and shows loading states. How do I test the different async scenarios with proper mocking?",
  "baseline_response": "Here's a comprehensive example of testing an async component with different scenarios using Jest and React Testing Library:\n\n```typescript\nimport React from 'react';\nimport { \n  render, \n  screen, \n  waitFor, \n  fireEvent \n} from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport axios from 'axios';\nimport UserList from './UserList';\n\n// Mock axios\njest.mock('axios');\nconst mockedAxios = axios as jest.Mocked<typeof axios>;\n\ndescribe('UserList Component', () => {\n  // Setup mock data\n  const mockUsers = [\n    { id: 1, name: 'John Doe', email: 'john@example.com' },\n    { id: 2, name: 'Jane Smith', email: 'jane@example.com' }\n  ];\n\n  // Reset mocks before each test\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  // Test successful data fetch\n  it('renders users when API call is successful', async () => {\n    // Setup successful mock response\n    mockedAxios.get.mockResolvedValue({\n      data: mockUsers,\n      status: 200\n    });\n\n    render(<UserList />);\n\n    // Check loading state\n    expect(screen.getByText(/loading/i)).toBeInTheDocument();\n\n    // Wait for users to load\n    await waitFor(() => {\n      expect(screen.getByText('John Doe')).toBeInTheDocument();\n      expect(screen.getByText('Jane Smith')).toBeInTheDocument();\n    });\n\n    // Verify axios was called\n    expect(mockedAxios.get).toHaveBeenCalledTimes(1);\n    expect(mockedAxios.get).toHaveBeenCalledWith('/api/users');\n  });\n\n  // Test error scenario\n  it('handles API error gracefully', async () => {\n    // Setup error mock response\n    mockedAxios.get.mockRejectedValue(new Error('Network Error'));\n\n    render(<UserList />);\n\n    // Check loading state\n    expect(screen.getByText(/loading/i)).toBeInTheDocument();\n\n    // Wait for error message\n    await waitFor(() => {\n      expect(screen.getByText(/error loading users/i)).toBeInTheDocument();\n    });\n  });\n\n  // Test empty state\n  it('shows empty state when no users are returned', async () => {\n    // Setup empty response\n    mockedAxios.get.mockResolvedValue({\n      data: [],\n      status: 200\n    });\n\n    render(<UserList />);\n\n    // Wait for empty state\n    await waitFor(() => {\n      expect(screen.getByText(/no users found/i)).toBeInTheDocument();\n    });\n  });\n\n  // Test retry functionality\n  it('allows retrying failed request', async () => {\n    // First call fails\n    mockedAxios.get\n      .mockRejectedValueOnce(new Error('First Error'))\n      // Second call succeeds\n      .mockResolvedValueOnce({\n        data: mockUsers,\n        status: 200\n      });\n\n    render(<UserList />);\n\n    // Wait for error message\n    await waitFor(() => {\n      expect(screen.getByText(/error loading users/i)).toBeInTheDocument();\n    });\n\n    // Click retry button\n    const retryButton = screen.getByText(/retry/i);\n    userEvent.click(retryButton);\n\n    // Wait for users to load\n    await waitFor(() => {\n      expect(screen.getByText('John Doe')).toBeInTheDocument();\n    });\n\n    // Verify axios was called twice\n    expect(mockedAxios.get).toHaveBeenCalledTimes(2);\n  });\n});\n\n// Example Component Implementation\nfunction UserList() {\n  const [users, setUsers] = useState<User[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  const fetchUsers = async () => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await axios.get('/api/users');\n      setUsers(response.data);\n    } catch (err) {\n      setError('Error loading users');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    fetchUsers();\n  }, []);\n\n  const handleRetry = () => {\n    fetchUsers();\n  };\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return (\n    <div>\n      {error}\n      <button onClick={handleRetry}>Retry</button>\n    </div>\n  );\n  if (users.length === 0) return <div>No users found</div>;\n\n  return (\n    <div>\n      {users.map(user => (\n        <div key={user.id}>\n          <h2>{user.name}</h2>\n          <p>{user.email}</p>\n        </div>\n      ))}\n    </div>\n  );\n}\n```\n\nKey Testing Strategies:\n1. Mock External Dependencies\n   - Use `jest.mock()` to mock axios\n   - Control response with `mockResolvedValue()` and `mockRejectedValue()`\n\n2. Test Different Scenarios\n   - Successful data fetch\n   - Error handling\n   - Empty state\n   - Retry mechanism\n\n3. Use `waitFor()` for Async Operations\n   - Handles timing of async renders\n   - Allows checking state after promise resolution\n\n4. Verify Component Behavior\n   - Check loading states\n   - Validate error messages\n   - Ensure correct rendering of data\n\nAdditional Best Practices:\n- Clear mocks between tests\n- Use descriptive test names\n- Cover various possible scenarios\n- Test both happy path and error cases\n\nTesting Libraries:\n- Jest for test runner\n- React Testing Library for rendering and querying\n- `@testing-library/user-event` for simulating user interactions\n\nAdvanced Techniques:\n- Use `jest.fn()` for more complex mock implementations\n- Create custom render functions for repeated setup\n- Use snapshot testing for complex render scenarios\n\nRecommendations:\n- Keep components small and focused\n- Separate data fetching logic when possible\n- Use custom hooks for reusable data fetching logic\n\nThis approach provides comprehensive test coverage for async components, ensuring robust error handling and user experience.",
  "skill_response": "I'll provide a comprehensive example of testing async components with API calls, covering loading, success, and error scenarios. I'll use a practical Dify-style approach with Vitest and React Testing Library.\n\n```typescript\nimport { render, screen, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { act } from 'react'\nimport { HttpResponse } from 'ky'\n\n// Component to test (hypothetical API interaction component)\nimport ModelParamConfigModal from '@/app/components/workflow/nodes/model-config/modal'\n\n// Mock the API service\nimport { fetchModelParams } from '@/service/common'\nvi.mock('@/service/common')\n\ndescribe('ModelParamConfigModal', () => {\n  // Sample mock data\n  const mockModelParams = {\n    temperature: 0.7,\n    maxTokens: 1000\n  }\n\n  // Reset mocks before each test\n  beforeEach(() => {\n    vi.clearAllMocks()\n  })\n\n  // Scenario 1: Successful API Call\n  describe('Successful Data Fetching', () => {\n    it('should render data after successful API call', async () => {\n      // Arrange: Mock successful API response\n      vi.mocked(fetchModelParams).mockResolvedValue(mockModelParams)\n\n      // Act: Render component\n      render(<ModelParamConfigModal modelId=\"test-model\" />)\n\n      // Assert: Loading state initially shown\n      expect(screen.getByTestId('loading-spinner')).toBeInTheDocument()\n\n      // Wait and assert loaded state\n      await waitFor(() => {\n        expect(screen.getByText('Temperature')).toBeInTheDocument()\n        expect(screen.getByDisplayValue('0.7')).toBeInTheDocument()\n      })\n    })\n  })\n\n  // Scenario 2: Error Handling\n  describe('Error Scenarios', () => {\n    it('should show error state when API call fails', async () => {\n      // Arrange: Mock API error\n      const mockError = new Error('Network Error')\n      vi.mocked(fetchModelParams).mockRejectedValue(mockError)\n\n      // Act: Render component\n      render(<ModelParamConfigModal modelId=\"test-model\" />)\n\n      // Assert: Error state shown\n      await waitFor(() => {\n        expect(screen.getByTestId('error-message')).toHaveTextContent('Network Error')\n      })\n    })\n\n    it('should handle 404 specific error', async () => {\n      // Arrange: Simulate 404 error\n      const mockHttpError = {\n        response: {\n          status: 404,\n          json: () => Promise.resolve({ message: 'Model not found' })\n        }\n      } as unknown as HttpResponse\n\n      vi.mocked(fetchModelParams).mockRejectedValue(mockHttpError)\n\n      // Act & Assert\n      render(<ModelParamConfigModal modelId=\"nonexistent\" />)\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('error-message'))\n          .toHaveTextContent('Model not found')\n      })\n    })\n  })\n\n  // Scenario 3: User Interactions with Async State\n  describe('User Interactions during Async Operations', () => {\n    it('should disable form during loading', async () => {\n      // Arrange: Create a slowly resolving mock\n      vi.mocked(fetchModelParams).mockImplementation(() => \n        new Promise(resolve => setTimeout(() => resolve(mockModelParams), 1000))\n      )\n\n      // Act: Render and attempt interaction\n      render(<ModelParamConfigModal modelId=\"test-model\" />)\n\n      // Assert: Form elements disabled during loading\n      await waitFor(() => {\n        const saveButton = screen.getByRole('button', { name: /save/i })\n        expect(saveButton).toBeDisabled()\n      })\n    })\n\n    it('should handle rapid parameter changes', async () => {\n      // Arrange: Mock successful API responses\n      vi.mocked(fetchModelParams).mockResolvedValue(mockModelParams)\n\n      // Act: Render and simulate user interaction\n      const user = userEvent.setup()\n      render(<ModelParamConfigModal modelId=\"test-model\" />)\n\n      // Wait for initial load\n      await waitFor(() => {\n        expect(screen.getByText('Temperature')).toBeInTheDocument()\n      })\n\n      // Simulate changing parameter\n      await act(async () => {\n        const temperatureInput = screen.getByLabelText('Temperature')\n        await user.clear(temperatureInput)\n        await user.type(temperatureInput, '0.5')\n      })\n\n      // Assert: Value updated correctly\n      expect(screen.getByDisplayValue('0.5')).toBeInTheDocument()\n    })\n  })\n\n  // Scenario 4: Retry Mechanism\n  describe('Retry Mechanism', () => {\n    it('should attempt retry on transient error', async () => {\n      // Arrange: Mock multiple failed attempts\n      const mockFetch = vi.mocked(fetchModelParams)\n      mockFetch\n        .mockRejectedValueOnce(new Error('First attempt failed'))\n        .mockRejectedValueOnce(new Error('Second attempt failed'))\n        .mockResolvedValue(mockModelParams)\n\n      // Act: Render component\n      render(<ModelParamConfigModal modelId=\"test-model\" />)\n\n      // Assert: Successful resolution after retries\n      await waitFor(() => {\n        expect(mockFetch).toHaveBeenCalledTimes(3)\n        expect(screen.getByText('Temperature')).toBeInTheDocument()\n      })\n    })\n  })\n})\n```\n\n## Key Testing Strategies Demonstrated\n\n### 1. API Mocking\n- Use `vi.mock()` to replace real API calls\n- Simulate different response scenarios (success, error, partial data)\n\n### 2. Async Testing Patterns\n- `waitFor()` for handling async operations\n- `act()` for wrapping async user interactions\n- Simulate different loading states\n\n### 3. Error Handling\n- Test various error scenarios (network errors, specific HTTP errors)\n- Verify error states and messages\n\n### 4. User Interaction Testing\n- Use `userEvent` for realistic interaction simulation\n- Test form behavior during async operations\n\n### 5. Advanced Mocking\n- Multiple mock implementations\n- Retry mechanism simulation\n\n## Best Practices\n\n- Always clear mocks with `vi.clearAllMocks()` before each test\n- Use meaningful test descriptions\n- Cover multiple scenarios (happy path, error states, edge cases)\n- Test both UI rendering and underlying logic\n\n### Recommended Component Structure\n\nTo make testing easier, structure your component to support these scenarios:\n\n```typescript\nfunction ModelParamConfigModal({ modelId }) {\n  const [isLoading, setIsLoading] = useState(true)\n  const [error, setError] = useState<Error | null>(null)\n  const [params, setParams] = useState<ModelParams | null>(null)\n\n  useEffect(() => {\n    async function fetchData() {\n      try {\n        setIsLoading(true)\n        const data = await fetchModelParams(modelId)\n        setParams(data)\n      } catch (err) {\n        setError(err instanceof Error ? err : new Error('Unknown error'))\n      } finally {\n        setIsLoading(false)\n      }\n    }\n\n    fetchData()\n  }, [modelId])\n\n  if (isLoading) return <LoadingSpinner data-testid=\"loading-spinner\" />\n  if (error) return <ErrorMessage error={error} data-testid=\"error-message\" />\n\n  return (\n    <form>\n      {/* Render params */}\n    </form>\n  )\n}\n```\n\n## Additional Tips\n\n1. Use `data-testid` attributes for reliable querying\n2. Mock only external dependencies\n3. Prefer integration-style tests over pure unit tests\n4. Test both UI and underlying logic\n5. Cover all possible states (loading, success, error)",
  "verdict": "skill",
  "reasoning": "Response A is superior in several key areas: 1) Technical accuracy - it uses Vitest instead of Jest, which is more modern and appropriate for current development environments; 2) Comprehensiveness - it covers more testing scenarios including HTTP-specific errors (404), retry mechanisms, form state during loading, and rapid user interactions; 3) Practical examples - it provides more realistic component structure with proper error boundaries and loading states; 4) Better testing practices - demonstrates more sophisticated mocking strategies with multiple mock implementations and proper async handling with act(); 5) Code quality - includes more detailed assertions, better error handling patterns, and more robust test organization. While Response B covers the basics well, Response A provides a more complete, modern, and practically applicable testing approach for async components.",
  "baseline_tokens": 1597,
  "skill_tokens": 4789,
  "position_a": "skill",
  "position_b": "baseline",
  "judge_model": "claude-sonnet-4-20250514",
  "judged_at": "2026-01-11T17:53:40.098826Z"
}