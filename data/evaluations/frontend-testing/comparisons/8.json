{
  "prompt": "My component is really complex with multiple contexts, API calls, and nested child components. I'm not sure how to structure the tests or what to mock vs test together.",
  "baseline_response": "Here's a comprehensive approach to testing a complex React component with multiple contexts, API calls, and nested child components:\n\n```typescript\nimport React from 'react';\nimport { \n  render, \n  screen, \n  waitFor, \n  fireEvent \n} from '@testing-library/react';\nimport { act } from 'react-dom/test-utils';\nimport axios from 'axios';\nimport MockAdapter from 'axios-mock-adapter';\n\n// Import all contexts and components\nimport { \n  AuthContext, \n  ThemeContext, \n  DataContext \n} from './contexts';\nimport ComplexComponent from './ComplexComponent';\n\n// Mock dependencies\njest.mock('./some-dependency', () => ({\n  customHook: () => ({\n    data: null,\n    loading: false\n  })\n}));\n\ndescribe('ComplexComponent', () => {\n  let axiosMock: MockAdapter;\n\n  beforeEach(() => {\n    // Setup axios mock\n    axiosMock = new MockAdapter(axios);\n\n    // Reset mocks before each test\n    jest.clearAllMocks();\n  });\n\n  afterEach(() => {\n    // Clean up axios mock\n    axiosMock.restore();\n  });\n\n  // Helper function to wrap component with all necessary providers\n  const renderWithProviders = (component: React.ReactNode) => {\n    return render(\n      <AuthContext.Provider value={{\n        user: { id: '123', name: 'Test User' },\n        login: jest.fn(),\n        logout: jest.fn()\n      }}>\n        <ThemeContext.Provider value={{\n          theme: 'light',\n          toggleTheme: jest.fn()\n        }}>\n          <DataContext.Provider value={{\n            data: [],\n            loading: false,\n            error: null,\n            fetchData: jest.fn()\n          }}>\n            {component}\n          </DataContext.Provider>\n        </ThemeContext.Provider>\n      </AuthContext.Provider>\n    );\n  };\n\n  // Test rendering with minimal mocked context\n  test('renders component correctly', () => {\n    renderWithProviders(<ComplexComponent />);\n    \n    // Check for key elements\n    expect(screen.getByTestId('main-container')).toBeInTheDocument();\n  });\n\n  // Test API interaction\n  test('fetches and displays data correctly', async () => {\n    // Mock API response\n    const mockData = [\n      { id: 1, name: 'Item 1' },\n      { id: 2, name: 'Item 2' }\n    ];\n\n    axiosMock.onGet('/api/data').reply(200, mockData);\n\n    await act(async () => {\n      renderWithProviders(<ComplexComponent />);\n    });\n\n    // Wait for and verify data rendering\n    await waitFor(() => {\n      expect(screen.getByText('Item 1')).toBeInTheDocument();\n      expect(screen.getByText('Item 2')).toBeInTheDocument();\n    });\n  });\n\n  // Test error handling\n  test('handles API error gracefully', async () => {\n    axiosMock.onGet('/api/data').reply(500);\n\n    await act(async () => {\n      renderWithProviders(<ComplexComponent />);\n    });\n\n    // Check error state\n    await waitFor(() => {\n      expect(screen.getByTestId('error-message')).toBeInTheDocument();\n    });\n  });\n\n  // Test user interactions\n  test('handles user interaction', async () => {\n    const mockSubmitFn = jest.fn();\n\n    renderWithProviders(\n      <ComplexComponent onSubmit={mockSubmitFn} />\n    );\n\n    // Simulate user interaction\n    const submitButton = screen.getByTestId('submit-button');\n    \n    fireEvent.click(submitButton);\n\n    // Verify interaction\n    expect(mockSubmitFn).toHaveBeenCalled();\n  });\n\n  // Test conditional rendering\n  test('renders different states correctly', () => {\n    const { rerender } = renderWithProviders(\n      <ComplexComponent loading={true} />\n    );\n\n    // Check loading state\n    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument();\n\n    // Rerender with different props\n    rerender(\n      <ComplexComponent loading={false} error=\"Test Error\" />\n    );\n\n    // Check error state\n    expect(screen.getByText('Test Error')).toBeInTheDocument();\n  });\n\n  // Test nested component interactions\n  test('nested component interactions work correctly', () => {\n    const mockChildInteraction = jest.fn();\n\n    renderWithProviders(\n      <ComplexComponent onChildAction={mockChildInteraction} />\n    );\n\n    // Simulate nested component action\n    const childActionTrigger = screen.getByTestId('child-action-trigger');\n    fireEvent.click(childActionTrigger);\n\n    // Verify child interaction\n    expect(mockChildInteraction).toHaveBeenCalled();\n  });\n});\n\n// Advanced mocking strategy for complex dependencies\nconst createMockContext = (overrides = {}) => ({\n  data: [],\n  loading: false,\n  error: null,\n  fetchData: jest.fn(),\n  ...overrides\n});\n```\n\nKey Testing Strategies:\n\n1. **Context Mocking**\n   - Create a helper function to wrap components with mock contexts\n   - Provide realistic mock implementations\n   - Allow easy overriding of context values\n\n2. **API Mocking**\n   - Use `axios-mock-adapter` for precise API response control\n   - Test various scenarios: success, error, loading states\n\n3. **Component Rendering**\n   - Test different rendering states\n   - Use `data-testid` attributes for reliable selection\n   - Verify key elements and interactions\n\n4. **Interaction Testing**\n   - Simulate user events with `fireEvent`\n   - Verify callback functions are called correctly\n\n5. **Async Testing**\n   - Use `act()` for async renders\n   - `waitFor()` to handle asynchronous updates\n\nRecommended Testing Approach:\n- Mock external dependencies\n- Use real contexts with mock implementations\n- Test component in isolation\n- Cover different states and interactions\n- Verify both rendering and behavior\n\nAdditional Tips:\n- Add `data-testid` attributes to make selection easier\n- Keep tests focused and atomic\n- Mock complex logic, test component behavior\n- Use snapshot testing for complex renders\n\nThis approach provides a comprehensive testing strategy for complex React components, ensuring thorough coverage of various scenarios and interactions.",
  "skill_response": "I'll help you break down testing a complex component systematically. I'll provide a comprehensive strategy tailored to multi-context, API-driven components in Dify. \n\n### ðŸ” Component Complexity Analysis Workflow\n\n#### Step 1: Component Decomposition\nBefore testing, let's categorize the complexity:\n\n```typescript\n// Complexity Scoring\nconst complexityScore = \n  (contextCount * 10) +  // Multiple contexts\n  (apiCallCount * 15) +  // External dependencies\n  (nestedComponentDepth * 5) +  // Component nesting\n  (stateManagementComplexity * 8)\n```\n\n#### Step 2: Mocking Strategy\nFor complex components, use a strategic mocking approach:\n\n```typescript\n// ðŸŸ¢ DO Mock (Always)\nvi.mock('@/service/api')           // External API calls\nvi.mock('next/navigation')          // Routing dependencies\nvi.mock('@/context/global-context') // Complex global contexts\n\n// ðŸ”´ DO NOT Mock\n// - Base components \n// - Sibling/child components in same directory\n// - Simple utility functions\n```\n\n#### Step 3: Test Structure Template\n\n```typescript\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport { renderHook, act } from '@testing-library/react-hooks'\n\n// Complex Component Test Structure\ndescribe('ComplexComponent', () => {\n  // 1. Setup Mocks & Contexts\n  const mockApiService = {\n    fetchData: vi.fn(),\n    createResource: vi.fn()\n  }\n\n  const mockGlobalContext = {\n    user: { id: 'test-user', role: 'admin' },\n    theme: 'dark'\n  }\n\n  beforeEach(() => {\n    // Reset mocks before each test\n    vi.clearAllMocks()\n    \n    // Provide mock implementations\n    mockApiService.fetchData.mockResolvedValue({\n      data: [],\n      total: 0\n    })\n  })\n\n  // 2. Rendering Tests\n  describe('Rendering', () => {\n    it('renders with all required contexts', async () => {\n      render(\n        <GlobalContext.Provider value={mockGlobalContext}>\n          <ApiServiceContext.Provider value={mockApiService}>\n            <ComplexComponent />\n          </ApiServiceContext.Provider>\n        </GlobalContext.Provider>\n      )\n\n      // Check critical elements render\n      await waitFor(() => {\n        expect(screen.getByTestId('component-root')).toBeInTheDocument()\n      })\n    })\n  })\n\n  // 3. API Interaction Tests\n  describe('API Interactions', () => {\n    it('fetches data on initial render', async () => {\n      render(<ComplexComponent />)\n\n      await waitFor(() => {\n        expect(mockApiService.fetchData).toHaveBeenCalledTimes(1)\n      })\n    })\n\n    it('handles API error states gracefully', async () => {\n      mockApiService.fetchData.mockRejectedValue(\n        new Error('Network Error')\n      )\n\n      render(<ComplexComponent />)\n\n      await waitFor(() => {\n        expect(screen.getByText(/error loading/i)).toBeInTheDocument()\n      })\n    })\n  })\n\n  // 4. User Interaction Tests\n  describe('User Interactions', () => {\n    it('submits form with validated data', async () => {\n      const mockSubmit = vi.fn()\n      \n      render(<ComplexComponent onSubmit={mockSubmit} />)\n      \n      const submitButton = screen.getByRole('button', { name: /submit/i })\n      \n      fireEvent.click(submitButton)\n\n      await waitFor(() => {\n        expect(mockSubmit).toHaveBeenCalledWith(\n          expect.objectContaining({\n            // Validate shape of submitted data\n            id: expect.any(String),\n            type: expect.any(String)\n          })\n        )\n      })\n    })\n  })\n\n  // 5. Context & State Tests\n  describe('Context Interactions', () => {\n    it('respects global theme context', () => {\n      render(\n        <ThemeContext.Provider value={{ mode: 'dark' }}>\n          <ComplexComponent />\n        </ThemeContext.Provider>\n      )\n\n      expect(screen.getByTestId('component-root')).toHaveClass('dark-theme')\n    })\n  })\n\n  // 6. Edge Cases & Boundary Testing\n  describe('Edge Cases', () => {\n    it('handles empty state', async () => {\n      mockApiService.fetchData.mockResolvedValue({ data: [], total: 0 })\n      \n      render(<ComplexComponent />)\n\n      await waitFor(() => {\n        expect(screen.getByText(/no data/i)).toBeInTheDocument()\n      })\n    })\n\n    it('manages loading states correctly', async () => {\n      const slowMockFetch = () => new Promise(resolve => \n        setTimeout(() => resolve({ data: [] }), 1000)\n      )\n      \n      mockApiService.fetchData.mockImplementation(slowMockFetch)\n\n      render(<ComplexComponent />)\n\n      expect(screen.getByTestId('loading-indicator')).toBeInTheDocument()\n    })\n  })\n})\n```\n\n### ðŸš€ Advanced Testing Techniques\n\n#### Handling Multiple Contexts\n- Use nested providers in render\n- Create mock context values matching real implementation\n- Test interactions between contexts\n\n#### API Call Management\n- Mock API service completely\n- Test different response scenarios\n  - Success\n  - Error\n  - Empty data\n  - Partial data\n\n#### Performance & Complexity Considerations\n- Break very complex components into smaller, testable units\n- Use `data-testid` attributes for reliable querying\n- Leverage `waitFor` for async operations\n\n### ðŸ“Š Coverage Recommendations\n\nFor complex components:\n- Aim for 95%+ line coverage\n- 90%+ branch coverage\n- Test ALL possible user flows\n- Verify error handling\n- Check context interactions\n\n### ðŸ”¬ Debugging Tips\n1. Use `console.log` in tests sparingly\n2. Leverage Vitest's verbose mode\n3. Break tests into smallest possible units\n4. Mock external dependencies completely\n\n### Next Steps\n1. Analyze your specific component\n2. Apply this template\n3. Incrementally add test cases\n4. Run coverage report\n5. Refactor if needed\n\nWould you like me to help you apply this strategy to a specific complex component you're working on? Share some details about its structure and I can provide a more tailored testing approach.",
  "verdict": "skill",
  "reasoning": "Response B is significantly better for several key reasons: 1) It provides a systematic, strategic approach with a complexity analysis workflow that helps users understand how to break down their specific testing challenges, 2) It offers clearer guidance on what to mock vs what not to mock with specific examples, 3) The test structure is more comprehensive and better organized with distinct sections for different types of testing (rendering, API, interactions, contexts, edge cases), 4) It includes advanced techniques like complexity scoring and performance considerations that are directly relevant to complex components, 5) The debugging tips and coverage recommendations provide actionable next steps. While Response A provides solid React testing examples, Response B offers a more strategic framework that specifically addresses the user's stated problem of not knowing 'how to structure tests or what to mock vs test together' for complex components with multiple contexts and API calls.",
  "baseline_tokens": 1612,
  "skill_tokens": 4458,
  "position_a": "baseline",
  "position_b": "skill",
  "judge_model": "claude-sonnet-4-20250514",
  "judged_at": "2026-01-11T16:54:41.335143Z"
}