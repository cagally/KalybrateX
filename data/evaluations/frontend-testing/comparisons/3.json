{
  "prompt": "I have a component that makes API calls and shows loading states. How do I test the different states - loading, success, and error?",
  "baseline_response": "Here's a comprehensive example of testing a component with different API call states using React Testing Library and Jest:\n\n```jsx\nimport React from 'react';\nimport { render, screen, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport axios from 'axios';\nimport UserDataComponent from './UserDataComponent';\n\n// Mock axios\njest.mock('axios');\n\ndescribe('UserDataComponent', () => {\n  // Test loading state\n  test('displays loading state when fetching data', async () => {\n    // Create a promise that doesn't resolve to simulate loading\n    axios.get.mockImplementation(() => new Promise(() => {}));\n\n    render(<UserDataComponent />);\n\n    // Check for loading indicator\n    expect(screen.getByText(/loading/i)).toBeInTheDocument();\n  });\n\n  // Test successful data fetch\n  test('displays user data on successful API call', async () => {\n    const mockUserData = {\n      id: 1,\n      name: 'John Doe',\n      email: 'john@example.com'\n    };\n\n    // Mock successful axios response\n    axios.get.mockResolvedValue({ data: mockUserData });\n\n    render(<UserDataComponent />);\n\n    // Wait for and check user data\n    await waitFor(() => {\n      expect(screen.getByText(mockUserData.name)).toBeInTheDocument();\n      expect(screen.getByText(mockUserData.email)).toBeInTheDocument();\n    });\n  });\n\n  // Test error state\n  test('displays error message on failed API call', async () => {\n    // Mock error response\n    axios.get.mockRejectedValue(new Error('Network error'));\n\n    render(<UserDataComponent />);\n\n    // Wait for and check error message\n    await waitFor(() => {\n      expect(screen.getByText(/error fetching data/i)).toBeInTheDocument();\n    });\n  });\n\n  // Test retry functionality (if applicable)\n  test('allows retrying failed API call', async () => {\n    // First call fails\n    axios.get.mockRejectedValueOnce(new Error('First attempt failed'));\n    \n    // Second call succeeds\n    const mockUserData = {\n      id: 1,\n      name: 'John Doe',\n      email: 'john@example.com'\n    };\n    axios.get.mockResolvedValueOnce({ data: mockUserData });\n\n    render(<UserDataComponent />);\n\n    // Find and click retry button\n    await waitFor(() => {\n      const retryButton = screen.getByRole('button', { name: /retry/i });\n      userEvent.click(retryButton);\n    });\n\n    // Verify data is displayed after retry\n    await waitFor(() => {\n      expect(screen.getByText(mockUserData.name)).toBeInTheDocument();\n    });\n  });\n});\n\n// Example component implementation\nfunction UserDataComponent() {\n  const [state, setState] = React.useState({\n    loading: true,\n    data: null,\n    error: null\n  });\n\n  const fetchData = async () => {\n    setState({ loading: true, data: null, error: null });\n    try {\n      const response = await axios.get('/api/user');\n      setState({ loading: false, data: response.data, error: null });\n    } catch (error) {\n      setState({ loading: false, data: null, error: error.message });\n    }\n  };\n\n  React.useEffect(() => {\n    fetchData();\n  }, []);\n\n  if (state.loading) return <div>Loading...</div>;\n  if (state.error) return (\n    <div>\n      Error fetching data\n      <button onClick={fetchData}>Retry</button>\n    </div>\n  );\n\n  return (\n    <div>\n      <h1>{state.data.name}</h1>\n      <p>{state.data.email}</p>\n    </div>\n  );\n}\n\nexport default UserDataComponent;\n```\n\nKey testing strategies:\n\n1. **Loading State**:\n   - Mock axios to return a never-resolving promise\n   - Check for loading indicator\n\n2. **Success State**:\n   - Mock axios to resolve with sample data\n   - Use `waitFor` to check for rendered data\n   - Verify correct data is displayed\n\n3. **Error State**:\n   - Mock axios to reject with an error\n   - Check for error message\n   - Test retry functionality if applicable\n\nAdditional tips:\n- Use `jest.mock()` to mock API calls\n- Use `waitFor()` for asynchronous operations\n- Test different scenarios: initial load, retry, etc.\n\nTesting libraries:\n- `@testing-library/react`: Rendering and querying\n- `@testing-library/user-event`: Simulating user interactions\n- Jest: Test runner and assertion library\n\nCommon patterns:\n- Create a loading state\n- Handle successful data fetch\n- Provide error handling\n- Optional retry mechanism\n\nThis approach ensures comprehensive coverage of different component states and API interaction scenarios.",
  "skill_response": "I'll provide a comprehensive example of testing a component with API calls, covering loading, success, and error states using Vitest and React Testing Library. I'll break this down step-by-step:\n\n```typescript\nimport { render, screen, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { vi } from 'vitest'\nimport DataFetchComponent from './DataFetchComponent'\n\n// Mock the API service\nvi.mock('@/service/api', () => ({\n  fetchData: vi.fn()\n}))\n\nimport { fetchData } from '@/service/api'\n\ndescribe('DataFetchComponent', () => {\n  // Setup mock for fetchData\n  const mockFetchData = vi.mocked(fetchData)\n\n  beforeEach(() => {\n    // Clear all mocks before each test\n    vi.clearAllMocks()\n  })\n\n  // 1. Initial Rendering Test\n  it('should render initial state', () => {\n    render(<DataFetchComponent />)\n    \n    // Check for initial button or trigger\n    expect(screen.getByRole('button', { name: /fetch data/i })).toBeInTheDocument()\n  })\n\n  // 2. Loading State Test\n  it('should show loading state when fetching data', async () => {\n    // Create a promise that never resolves to simulate loading\n    mockFetchData.mockReturnValue(new Promise(() => {}))\n\n    render(<DataFetchComponent />)\n    \n    // Trigger data fetch\n    const fetchButton = screen.getByRole('button', { name: /fetch data/i })\n    userEvent.click(fetchButton)\n\n    // Assert loading state\n    await waitFor(() => {\n      expect(screen.getByText(/loading/i)).toBeInTheDocument()\n      expect(fetchButton).toBeDisabled()\n    })\n  })\n\n  // 3. Success State Test\n  it('should render data on successful fetch', async () => {\n    const mockData = {\n      id: '1',\n      name: 'Test Item',\n      description: 'Test Description'\n    }\n\n    // Mock successful API response\n    mockFetchData.mockResolvedValue(mockData)\n\n    render(<DataFetchComponent />)\n    \n    // Trigger data fetch\n    const fetchButton = screen.getByRole('button', { name: /fetch data/i })\n    userEvent.click(fetchButton)\n\n    // Wait for and assert success state\n    await waitFor(() => {\n      expect(screen.getByText(mockData.name)).toBeInTheDocument()\n      expect(screen.getByText(mockData.description)).toBeInTheDocument()\n      expect(fetchButton).toBeEnabled()\n    })\n  })\n\n  // 4. Error State Test\n  it('should handle and display error state', async () => {\n    // Mock API error\n    const errorMessage = 'Failed to fetch data'\n    mockFetchData.mockRejectedValue(new Error(errorMessage))\n\n    render(<DataFetchComponent />)\n    \n    // Trigger data fetch\n    const fetchButton = screen.getByRole('button', { name: /fetch data/i })\n    userEvent.click(fetchButton)\n\n    // Assert error state\n    await waitFor(() => {\n      expect(screen.getByText(/error/i)).toBeInTheDocument()\n      expect(screen.getByText(errorMessage)).toBeInTheDocument()\n      expect(fetchButton).toBeEnabled()\n    })\n  })\n\n  // 5. Multiple Fetch Interactions Test\n  it('should prevent multiple simultaneous fetches', async () => {\n    // Create a never-resolving promise to simulate ongoing fetch\n    mockFetchData.mockReturnValue(new Promise(() => {}))\n\n    render(<DataFetchComponent />)\n    \n    const fetchButton = screen.getByRole('button', { name: /fetch data/i })\n    \n    // Try to click multiple times\n    userEvent.click(fetchButton)\n    userEvent.click(fetchButton)\n    userEvent.click(fetchButton)\n\n    // Assert only one fetch is triggered\n    await waitFor(() => {\n      expect(mockFetchData).toHaveBeenCalledTimes(1)\n    })\n  })\n})\n\n// Example Component Structure (for reference)\nfunction DataFetchComponent() {\n  const [data, setData] = useState(null)\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState(null)\n\n  const handleFetch = async () => {\n    setLoading(true)\n    setError(null)\n    try {\n      const result = await fetchData()\n      setData(result)\n    } catch (err) {\n      setError(err.message)\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  return (\n    <div>\n      <button \n        onClick={handleFetch} \n        disabled={loading}\n      >\n        Fetch Data\n      </button>\n      \n      {loading && <div>Loading...</div>}\n      {error && <div>Error: {error}</div>}\n      {data && (\n        <div>\n          <h2>{data.name}</h2>\n          <p>{data.description}</p>\n        </div>\n      )}\n    </div>\n  )\n}\n```\n\n### Key Testing Strategies\n\n1. **Mocking API Calls**\n   - Use `vi.mock()` to replace actual API implementation\n   - Control return values with `.mockResolvedValue()`, `.mockRejectedValue()`\n\n2. **State Coverage**\n   - Test initial state\n   - Test loading state\n   - Test successful data fetch\n   - Test error handling\n\n3. **User Interaction Testing**\n   - Simulate button clicks with `userEvent`\n   - Check button states (enabled/disabled)\n   - Prevent multiple simultaneous fetches\n\n4. **Async Testing Techniques**\n   - Use `waitFor()` for async assertions\n   - Handle promises and state changes\n   - Test different promise scenarios\n\n### Best Practices\n\n- Mock external dependencies\n- Clear mocks between tests\n- Test all possible state transitions\n- Use semantic queries\n- Cover edge cases (multiple clicks, error scenarios)\n\n### Pro Tips\n\n- Use `vi.mocked()` for type-safe mocking\n- Leverage `userEvent` over `fireEvent` for more realistic interactions\n- Always reset mocks with `vi.clearAllMocks()`\n- Use `waitFor()` for async state changes\n\nThis approach provides comprehensive test coverage for a data-fetching component, ensuring it behaves correctly under various conditions.",
  "verdict": "skill",
  "reasoning": "Response B is superior in several key areas. It provides more modern tooling (Vitest instead of Jest), better TypeScript integration with proper type safety using vi.mocked(), and more comprehensive test coverage including edge cases like preventing multiple simultaneous fetches. Response B also demonstrates better testing practices with proper mock cleanup using vi.clearAllMocks(), more realistic user interactions with userEvent, and clearer separation of concerns. The code structure is more professional with better organization and includes more detailed explanations of testing strategies and best practices. While Response A covers the basics well, Response B offers a more complete, modern, and production-ready approach to testing API states.",
  "baseline_tokens": 1238,
  "skill_tokens": 4444,
  "position_a": "baseline",
  "position_b": "skill",
  "judge_model": "claude-sonnet-4-20250514",
  "judged_at": "2026-01-11T16:51:19.792297Z"
}