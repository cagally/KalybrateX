{
  "prompt": "Can you write some basic unit tests for my React button component? It has props like onClick, disabled, and className",
  "baseline_response": "Here's an example of unit tests for a React button component using Jest and React Testing Library. I'll provide a comprehensive set of tests that cover various scenarios:\n\n```jsx\nimport React from 'react';\nimport { render, fireEvent, screen } from '@testing-library/react';\nimport Button from './Button'; // Adjust the import path as needed\n\ndescribe('Button Component', () => {\n  // Basic rendering test\n  test('renders button correctly', () => {\n    render(<Button>Click me</Button>);\n    const buttonElement = screen.getByRole('button', { name: /click me/i });\n    expect(buttonElement).toBeInTheDocument();\n  });\n\n  // Test onClick functionality\n  test('calls onClick prop when clicked', () => {\n    const handleClick = jest.fn();\n    render(<Button onClick={handleClick}>Click me</Button>);\n    \n    const buttonElement = screen.getByRole('button');\n    fireEvent.click(buttonElement);\n    \n    expect(handleClick).toHaveBeenCalledTimes(1);\n  });\n\n  // Test disabled state\n  test('does not call onClick when disabled', () => {\n    const handleClick = jest.fn();\n    render(<Button disabled onClick={handleClick}>Click me</Button>);\n    \n    const buttonElement = screen.getByRole('button');\n    expect(buttonElement).toBeDisabled();\n    \n    fireEvent.click(buttonElement);\n    expect(handleClick).not.toHaveBeenCalled();\n  });\n\n  // Test custom className\n  test('applies custom className', () => {\n    render(<Button className=\"custom-button\">Click me</Button>);\n    \n    const buttonElement = screen.getByRole('button');\n    expect(buttonElement).toHaveClass('custom-button');\n  });\n\n  // Test combination of props\n  test('renders with multiple props', () => {\n    const handleClick = jest.fn();\n    render(\n      <Button \n        onClick={handleClick} \n        disabled={false} \n        className=\"test-btn\"\n      >\n        Click me\n      </Button>\n    );\n    \n    const buttonElement = screen.getByRole('button');\n    expect(buttonElement).toHaveClass('test-btn');\n    expect(buttonElement).not.toBeDisabled();\n    \n    fireEvent.click(buttonElement);\n    expect(handleClick).toHaveBeenCalledTimes(1);\n  });\n\n  // Test default props\n  test('renders with default props', () => {\n    render(<Button>Default Button</Button>);\n    \n    const buttonElement = screen.getByRole('button');\n    expect(buttonElement).toBeInTheDocument();\n    expect(buttonElement).not.toBeDisabled();\n  });\n});\n```\n\nAnd here's a sample implementation of the Button component that these tests would work with:\n\n```jsx\nimport React from 'react';\nimport PropTypes from 'prop-types';\n\nconst Button = ({ \n  children, \n  onClick, \n  disabled = false, \n  className = '',\n  ...rest \n}) => {\n  const handleClick = (e) => {\n    if (!disabled && onClick) {\n      onClick(e);\n    }\n  };\n\n  return (\n    <button\n      className={`btn ${className}`}\n      onClick={handleClick}\n      disabled={disabled}\n      {...rest}\n    >\n      {children}\n    </button>\n  );\n};\n\nButton.propTypes = {\n  children: PropTypes.node.isRequired,\n  onClick: PropTypes.func,\n  disabled: PropTypes.bool,\n  className: PropTypes.string\n};\n\nexport default Button;\n```\n\nTo run these tests, you'll need to have the following dev dependencies installed:\n- @testing-library/react\n- @testing-library/jest-dom\n- jest\n\nYou might also want to add a setup file for testing library:\n\n```jsx\n// setupTests.js\nimport '@testing-library/jest-dom';\n```\n\nAnd configure your jest configuration to use this setup file.\n\nThese tests cover:\n1. Basic rendering\n2. Click event handling\n3. Disabled state\n4. Custom className\n5. Combination of props\n6. Default props\n\nThe tests check that:\n- The button renders correctly\n- Click events work when not disabled\n- Clicks are prevented when disabled\n- Custom classes are applied\n- Multiple props work together\n\nFeel free to adjust the tests or component implementation to match your specific use case.",
  "skill_response": "I'll help you write comprehensive unit tests for a React button component using Vitest and React Testing Library. I'll provide a template that covers rendering, props, and interaction scenarios.\n\n```typescript\nimport { render, screen, fireEvent } from '@testing-library/react'\nimport Button from './Button'  // Adjust import path as needed\n\ndescribe('Button Component', () => {\n  // Rendering Tests\n  describe('Rendering', () => {\n    it('should render button with default props', () => {\n      render(<Button>Click me</Button>)\n      const buttonElement = screen.getByRole('button', { name: /click me/i })\n      \n      expect(buttonElement).toBeInTheDocument()\n      expect(buttonElement).toBeEnabled()\n    })\n\n    it('should apply custom className', () => {\n      render(<Button className=\"custom-button\">Test</Button>)\n      const buttonElement = screen.getByRole('button', { name: /test/i })\n      \n      expect(buttonElement).toHaveClass('custom-button')\n    })\n  })\n\n  // Props Tests\n  describe('Props Behavior', () => {\n    it('should render disabled state when disabled prop is true', () => {\n      render(<Button disabled>Disabled Button</Button>)\n      const buttonElement = screen.getByRole('button', { name: /disabled button/i })\n      \n      expect(buttonElement).toBeDisabled()\n    })\n\n    it('should apply additional className when disabled', () => {\n      render(<Button disabled className=\"test-class\">Disabled</Button>)\n      const buttonElement = screen.getByRole('button', { name: /disabled/i })\n      \n      expect(buttonElement).toHaveClass('test-class')\n      expect(buttonElement).toBeDisabled()\n    })\n  })\n\n  // Interaction Tests\n  describe('User Interactions', () => {\n    it('should call onClick handler when button is clicked', () => {\n      const handleClick = vi.fn()\n      render(<Button onClick={handleClick}>Click me</Button>)\n      const buttonElement = screen.getByRole('button', { name: /click me/i })\n      \n      fireEvent.click(buttonElement)\n      \n      expect(handleClick).toHaveBeenCalledTimes(1)\n    })\n\n    it('should not call onClick when button is disabled', () => {\n      const handleClick = vi.fn()\n      render(<Button disabled onClick={handleClick}>Disabled</Button>)\n      const buttonElement = screen.getByRole('button', { name: /disabled/i })\n      \n      fireEvent.click(buttonElement)\n      \n      expect(handleClick).not.toHaveBeenCalled()\n    })\n  })\n\n  // Children and Content Tests\n  describe('Content Rendering', () => {\n    it('should render children text correctly', () => {\n      render(<Button>Submit Form</Button>)\n      const buttonElement = screen.getByRole('button', { name: /submit form/i })\n      \n      expect(buttonElement).toHaveTextContent('Submit Form')\n    })\n\n    it('should render complex children', () => {\n      render(\n        <Button>\n          <span>Icon</span>\n          Submit\n        </Button>\n      )\n      const buttonElement = screen.getByRole('button')\n      \n      expect(buttonElement).toContainElement(screen.getByText('Icon'))\n      expect(buttonElement).toHaveTextContent('Submit')\n    })\n  })\n\n  // Edge Cases\n  describe('Edge Cases', () => {\n    it('should handle null/undefined children gracefully', () => {\n      render(<Button>{null}</Button>)\n      const buttonElement = screen.getByRole('button')\n      \n      expect(buttonElement).toBeInTheDocument()\n    })\n  })\n})\n```\n\nThis test suite covers multiple scenarios for a typical React button component:\n\n1. Basic rendering\n2. Custom className application\n3. Disabled state\n4. Click interactions\n5. Children rendering\n6. Edge cases\n\nTo use these tests, ensure you have the following setup:\n\n```bash\n# Install dev dependencies if not already present\npnpm install -D vitest @testing-library/react @testing-library/jest-dom\n```\n\nA sample implementation of the Button component might look like:\n\n```typescript\nimport React from 'react'\nimport classNames from 'classnames'\n\ninterface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {\n  className?: string\n}\n\nconst Button: React.FC<ButtonProps> = ({\n  children, \n  className, \n  disabled = false, \n  ...rest \n}) => {\n  return (\n    <button\n      className={classNames('base-button', className, {\n        'button-disabled': disabled\n      })}\n      disabled={disabled}\n      {...rest}\n    >\n      {children}\n    </button>\n  )\n}\n\nexport default Button\n```\n\n### Recommendations:\n\n1. Adjust import paths to match your project structure\n2. Customize the tests based on your specific button implementation\n3. Run tests with `pnpm test` or `vitest`\n4. Aim for comprehensive coverage of different scenarios\n\nWould you like me to elaborate on any part of the test suite or discuss any specific testing requirements for your button component?",
  "verdict": "tie",
  "reasoning": "Both responses provide comprehensive, well-structured unit tests for a React button component that effectively cover the same key scenarios: basic rendering, onClick functionality, disabled state, className application, and edge cases. Response A uses Jest with more traditional test structure and includes helpful setup information, while Response B uses Vitest with TypeScript and better test organization through nested describe blocks. Response A provides more detailed setup instructions and PropTypes usage, while Response B offers better test categorization and TypeScript interface examples. Both include sample component implementations and are equally practical and actionable. The main differences are in testing framework choice (Jest vs Vitest) and organization style, but both are high-quality, complete solutions that would work well for the user's needs.",
  "baseline_tokens": 1092,
  "skill_tokens": 4110,
  "position_a": "baseline",
  "position_b": "skill",
  "judge_model": "claude-sonnet-4-20250514",
  "judged_at": "2026-01-11T17:51:06.837843Z"
}