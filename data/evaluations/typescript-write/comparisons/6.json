{
  "prompt": "Help me create a TypeScript generic function that can work with different data types while maintaining type safety",
  "baseline_response": "Here's an example of a generic function in TypeScript that demonstrates type safety and flexibility:\n\n```typescript\n// Generic function with multiple type constraints and type inference\nfunction processData<T extends object, K extends keyof T>(\n  data: T[], \n  key: K, \n  transformer?: (value: T[K]) => any\n): { \n  processedData: any[], \n  originalType: string \n} {\n  // Type-safe processing of data\n  const processedData = data.map(item => {\n    // Extract the value for the specified key\n    const value = item[key];\n    \n    // Apply optional transformer if provided\n    return transformer ? transformer(value) : value;\n  });\n\n  return {\n    processedData,\n    originalType: typeof data[0]?.[key]\n  };\n}\n\n// Example usage with different types\n\n// Example 1: Working with an array of objects\ninterface User {\n  id: number;\n  name: string;\n  age: number;\n}\n\nconst users: User[] = [\n  { id: 1, name: 'Alice', age: 30 },\n  { id: 2, name: 'Bob', age: 25 }\n];\n\nconst processedUserNames = processData(users, 'name');\nconsole.log(processedUserNames);\n// Output: { processedData: ['Alice', 'Bob'], originalType: 'string' }\n\n// Example 2: With a transformer function\nconst processedUserAges = processData(users, 'age', age => age * 2);\nconsole.log(processedUserAges);\n// Output: { processedData: [60, 50], originalType: 'number' }\n\n// Example 3: Working with a different type of array\ninterface Product {\n  productId: string;\n  price: number;\n  inStock: boolean;\n}\n\nconst products: Product[] = [\n  { productId: 'A1', price: 100, inStock: true },\n  { productId: 'B2', price: 200, inStock: false }\n];\n\nconst processedProductIds = processData(products, 'productId');\nconsole.log(processedProductIds);\n// Output: { processedData: ['A1', 'B2'], originalType: 'string' }\n\n// Advanced example with type-safe optional transformer\nfunction createUppercaseTransformer<T extends string>(\n  data: T[]\n): { \n  processedData: string[], \n  originalType: string \n} {\n  return processData(data, 0, (value: T) => value.toUpperCase());\n}\n\nconst names = ['alice', 'bob', 'charlie'];\nconst uppercaseNames = createUppercaseTransformer(names);\nconsole.log(uppercaseNames);\n// Output: { processedData: ['ALICE', 'BOB', 'CHARLIE'], originalType: 'string' }\n\n// Demonstrating type safety with compile-time checks\nfunction demonstrateTypeSafety() {\n  // These will work correctly\n  processData(users, 'name');\n  processData(users, 'age', age => age.toFixed(2));\n\n  // These would cause compile-time errors\n  // processData(users, 'email'); // Error: Argument of type '\"email\"' is not assignable to parameter of type 'keyof User'\n  // processData(users, 'age', (name: string) => name.toUpperCase()); // Type mismatch\n}\n```\n\nThis example showcases several key aspects of generics in TypeScript:\n\n1. **Type Constraints**: \n   - `T extends object` ensures the input is an object\n   - `K extends keyof T` ensures the key exists in the object type\n\n2. **Flexible Processing**:\n   - The function can work with different array types\n   - Optional transformer allows custom processing\n   - Returns both processed data and original type information\n\n3. **Type Safety**:\n   - Compile-time type checking\n   - Prevents incorrect key or transformer usage\n   - Maintains type information throughout the process\n\n4. **Versatility**:\n   - Works with different array types (users, products, etc.)\n   - Supports optional transformations\n\n5. **Type Inference**:\n   - TypeScript automatically infers the types\n   - Provides strong typing without explicit type annotations\n\nKey Benefits:\n- Reusable function that works with multiple types\n- Compile-time type checking\n- Flexible data processing\n- Minimal runtime overhead\n\nYou can further extend this pattern to create more complex generic utilities, such as:\n- Filtering\n- Mapping\n- Reducing\n- Validation helpers\n\nThis approach demonstrates how generics in TypeScript provide powerful type-safe abstractions that work across different data types while maintaining strong type checking.",
  "skill_response": "I'll provide a comprehensive example of creating a type-safe generic function in TypeScript with multiple approaches and best practices:\n\n```typescript\n// Basic Generic Function\nfunction identity<T>(value: T): T {\n  return value;\n}\n\n// Generic Function with Constraints\nfunction processValue<T extends string | number>(value: T): T {\n  console.log(`Processing value: ${value}`);\n  return value;\n}\n\n// Generic Function with Multiple Type Parameters\nfunction compareValues<T, U>(\n  value1: T, \n  value2: U\n): boolean {\n  return value1 === value2;\n}\n\n// Advanced Generic Function with Type Constraints\ninterface Lengthwise {\n  length: number;\n}\n\nfunction getLength<T extends Lengthwise>(input: T): number {\n  return input.length;\n}\n\n// Generic Class Example\nclass GenericContainer<T> {\n  private value: T;\n\n  constructor(value: T) {\n    this.value = value;\n  }\n\n  getValue(): T {\n    return this.value;\n  }\n\n  setValue(newValue: T): void {\n    this.value = newValue;\n  }\n}\n\n// Usage Examples\nfunction demonstrateGenerics() {\n  // Basic usage\n  const numberResult = identity(42);\n  const stringResult = identity(\"Hello\");\n\n  // Constrained usage\n  const processedNumber = processValue(100);\n  // processValue(true); // Type error\n\n  // Multiple type parameters\n  const areEqual = compareValues(5, \"5\"); // false\n  const areNumEqual = compareValues(5, 5); // true\n\n  // Length-based generic\n  const stringLength = getLength(\"TypeScript\");\n  const arrayLength = getLength([1, 2, 3]);\n  // getLength(42); // Type error\n\n  // Generic class\n  const numberContainer = new GenericContainer<number>(42);\n  const stringContainer = new GenericContainer<string>(\"Hello\");\n}\n\n// Advanced Generic Function with Conditional Types\ntype ExtractType<T> = T extends Array<infer U> ? U : T;\n\nfunction extractFirstOrValue<T>(input: T): ExtractType<T> {\n  if (Array.isArray(input)) {\n    return input[0];\n  }\n  return input as ExtractType<T>;\n}\n\n// Example of Generic Function with Default Type\nfunction createArray<T = string>(length: number, value: T): T[] {\n  return Array(length).fill(value);\n}\n```\n\n## Best Practices for Generic Functions\n\n1. **Type Safety**: Use generics to maintain type information\n2. **Constraints**: Use `extends` to limit acceptable types\n3. **Multiple Type Parameters**: Allow flexible type handling\n4. **Inference**: Let TypeScript infer types when possible\n\n### Key Concepts Demonstrated\n\n- Generic Functions\n- Type Constraints\n- Type Inference\n- Conditional Types\n- Default Types\n\n### Advanced Typing Techniques\n\n```typescript\n// Utility Type for Nullable Types\ntype Nullable<T> = T | null | undefined;\n\n// Generic Type Guard\nfunction isNotNull<T>(value: Nullable<T>): value is T {\n  return value !== null && value !== undefined;\n}\n\n// Complex Generic Type Manipulation\ntype FilterOutNull<T> = {\n  [K in keyof T]: NonNullable<T[K]>;\n};\n```\n\n### Error Handling with Generics\n\n```typescript\nfunction safeParse<T>(\n  parser: (input: unknown) => T\n): (input: unknown) => T | null {\n  return (input: unknown) => {\n    try {\n      return parser(input);\n    } catch {\n      return null;\n    }\n  };\n}\n```\n\n## When to Use Generics\n\n- Creating reusable, type-safe functions\n- Implementing data structures\n- Writing utility functions\n- Creating flexible APIs\n\n### Performance Considerations\n\n- Generics are resolved at compile-time\n- No runtime overhead\n- Provides type checking without performance penalty\n\n## Recommended Linting and Tooling\n\n```json\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true,\n    \"strictFunctionTypes\": true\n  }\n}\n```\n\n### Common Pitfalls to Avoid\n\n- Overusing generics\n- Creating overly complex type constraints\n- Neglecting type safety\n- Ignoring compile-time type checks\n\nBy following these patterns, you can create flexible, type-safe, and maintainable TypeScript code that leverages the power of generics.",
  "verdict": "skill",
  "reasoning": "Response B is significantly more comprehensive and educational. While Response A provides a single complex example with good type safety principles, Response B offers a complete learning progression from basic to advanced generics concepts. B includes multiple patterns (basic generics, constraints, multiple type parameters, conditional types, default types), best practices, error handling, performance considerations, tooling recommendations, and common pitfalls. B's structured approach with clear sections makes it more actionable for developers at different skill levels. Response A's single complex example, while well-explained, may overwhelm beginners and doesn't cover the breadth of generic patterns that B provides. B better addresses the user's need to understand how generics work with different data types through its graduated examples and comprehensive coverage.",
  "baseline_tokens": 1163,
  "skill_tokens": 1197,
  "position_a": "baseline",
  "position_b": "skill",
  "judge_model": "claude-sonnet-4-20250514",
  "judged_at": "2026-01-11T18:59:52.658675Z"
}