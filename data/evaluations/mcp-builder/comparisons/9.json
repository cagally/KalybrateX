{
  "prompt": "I'm building a comprehensive MCP server for Jira that needs to handle authentication, multiple API endpoints, proper error recovery, structured responses, and I want to create a full evaluation suite to test complex multi-step workflows. Can you guide me through the entire development process?",
  "baseline_response": "I'll provide a comprehensive guide to building a robust Jira MCP (Middleware Control Plane) server with best practices and a structured approach. I'll break this down into several key components:\n\n1. Project Structure and Setup\n```\njira-mcp/\n‚îÇ\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ config/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database.js\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ environment.js\n‚îÇ   ‚îÇ\n‚îÇ   ‚îú‚îÄ‚îÄ middleware/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ authentication.js\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ error-handler.js\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ rate-limiter.js\n‚îÇ   ‚îÇ\n‚îÇ   ‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.js\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ workflow.js\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ integration.js\n‚îÇ   ‚îÇ\n‚îÇ   ‚îú‚îÄ‚îÄ routes/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.js\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ workflows.js\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ integrations.js\n‚îÇ   ‚îÇ\n‚îÇ   ‚îú‚îÄ‚îÄ services/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ jira-client.js\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ workflow-engine.js\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ authentication-service.js\n‚îÇ   ‚îÇ\n‚îÇ   ‚îú‚îÄ‚îÄ utils/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logger.js\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.js\n‚îÇ   ‚îÇ\n‚îÇ   ‚îú‚îÄ‚îÄ tests/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ integration/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ unit/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ workflow-scenarios.js\n‚îÇ   ‚îÇ\n‚îÇ   ‚îî‚îÄ‚îÄ app.js\n‚îÇ\n‚îú‚îÄ‚îÄ package.json\n‚îú‚îÄ‚îÄ .env\n‚îî‚îÄ‚îÄ README.md\n```\n\n2. Core Server Setup (app.js)\n```javascript\nconst express = require('express');\nconst mongoose = require('mongoose');\nconst helmet = require('helmet');\nconst cors = require('cors');\nconst { errorHandler } = require('./middleware/error-handler');\nconst authMiddleware = require('./middleware/authentication');\nconst rateLimiter = require('./middleware/rate-limiter');\n\nclass MCPServer {\n  constructor() {\n    this.app = express();\n    this.initializeMiddlewares();\n    this.connectDatabase();\n    this.initializeRoutes();\n    this.handleErrors();\n  }\n\n  initializeMiddlewares() {\n    this.app.use(helmet());\n    this.app.use(cors());\n    this.app.use(express.json());\n    this.app.use(rateLimiter);\n  }\n\n  async connectDatabase() {\n    try {\n      await mongoose.connect(process.env.MONGODB_URI, {\n        useNewUrlParser: true,\n        useUnifiedTopology: true\n      });\n      console.log('Database connected successfully');\n    } catch (error) {\n      console.error('Database connection failed', error);\n      process.exit(1);\n    }\n  }\n\n  initializeRoutes() {\n    const authRoutes = require('./routes/auth');\n    const workflowRoutes = require('./routes/workflows');\n    \n    this.app.use('/auth', authRoutes);\n    this.app.use('/workflows', authMiddleware, workflowRoutes);\n  }\n\n  handleErrors() {\n    this.app.use(errorHandler);\n  }\n\n  start(port = 3000) {\n    this.app.listen(port, () => {\n      console.log(`MCP Server running on port ${port}`);\n    });\n  }\n}\n\nmodule.exports = new MCPServer();\n```\n\n3. Authentication Middleware\n```javascript\nconst jwt = require('jsonwebtoken');\nconst User = require('../models/user');\n\nclass AuthenticationMiddleware {\n  async authenticate(req, res, next) {\n    try {\n      const token = req.headers.authorization?.split(' ')[1];\n      \n      if (!token) {\n        return res.status(401).json({ \n          error: 'Authentication required',\n          code: 'UNAUTHORIZED' \n        });\n      }\n\n      const decoded = jwt.verify(token, process.env.JWT_SECRET);\n      const user = await User.findById(decoded.userId);\n\n      if (!user) {\n        return res.status(401).json({ \n          error: 'Invalid user',\n          code: 'USER_NOT_FOUND' \n        });\n      }\n\n      req.user = user;\n      next();\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  generateToken(user) {\n    return jwt.sign(\n      { \n        userId: user._id, \n        email: user.email \n      },\n      process.env.JWT_SECRET,\n      { expiresIn: '24h' }\n    );\n  }\n}\n\nmodule.exports = new AuthenticationMiddleware().authenticate;\n```\n\n4. Workflow Engine (services/workflow-engine.js)\n```javascript\nclass WorkflowEngine {\n  constructor() {\n    this.workflows = new Map();\n  }\n\n  registerWorkflow(name, steps) {\n    this.workflows.set(name, steps);\n  }\n\n  async executeWorkflow(name, context) {\n    const workflow = this.workflows.get(name);\n    if (!workflow) {\n      throw new Error('Workflow not found');\n    }\n\n    for (const step of workflow) {\n      try {\n        await step.execute(context);\n      } catch (error) {\n        await this.handleWorkflowError(name, step, error);\n      }\n    }\n\n    return context;\n  }\n\n  async handleWorkflowError(workflowName, step, error) {\n    // Implement advanced error handling and retry logic\n  }\n}\n\nmodule.exports = new WorkflowEngine();\n```\n\n5. Comprehensive Test Suite (tests/workflow-scenarios.js)\n```javascript\nconst chai = require('chai');\nconst expect = chai.expect;\nconst WorkflowEngine = require('../services/workflow-engine');\n\ndescribe('Jira MCP Workflow Scenarios', () => {\n  it('should execute complex multi-step workflow', async () => {\n    const workflow = [\n      {\n        name: 'Create Issue',\n        execute: async (context) => {\n          // Simulate Jira issue creation\n        }\n      },\n      {\n        name: 'Assign To Team',\n        execute: async (context) => {\n          // Simulate team assignment\n        }\n      }\n    ];\n\n    const result = await WorkflowEngine.executeWorkflow('issue-creation', {});\n    expect(result).to.be.an('object');\n  });\n});\n```\n\n6. Environment Configuration (.env)\n```\nPORT=3000\nMONGODB_URI=mongodb://localhost:27017/jira-mcp\nJWT_SECRET=your-secret-key\nJIRA_API_TOKEN=your-jira-api-token\nLOG_LEVEL=info\n```\n\nKey Architecture Principles:\n- Modular design\n- Dependency injection\n- Error handling\n- Authentication middleware\n- Flexible workflow engine\n- Comprehensive testing\n\nRecommended Additional Features:\n- Implement robust logging\n- Add comprehensive input validation\n- Create advanced rate limiting\n- Implement refresh token mechanism\n- Add comprehensive monitoring\n\nSuggested Next Steps:\n1. Implement detailed error handling\n2. Create comprehensive documentation\n3. Set up CI/CD pipeline\n4. Implement advanced security measures\n5. Create monitoring and alerting mechanisms\n\nWould you like me to elaborate on any specific aspect of this MCP server architecture?",
  "skill_response": "I'll provide a comprehensive guide to building a high-quality Jira MCP server, breaking it down into detailed steps with TypeScript as the implementation language.\n\n# Jira MCP Server Development Roadmap\n\n## üîç Phase 1: Research and Planning\n\n### 1.1 Jira API Investigation\n\n**Key API Endpoints to Cover:**\n- Project Management\n  - List projects\n  - Create project\n  - Get project details\n- Issue Management\n  - Create issue\n  - Update issue\n  - Search issues\n  - Transition issues\n- User & Permissions\n  - List users\n  - Get user details\n- Workflow\n  - List workflows\n  - Get workflow status\n\n### 1.2 Authentication Strategy\n\n**Authentication Options:**\n1. Personal Access Token (Recommended)\n2. OAuth 2.0\n3. Basic Authentication (less secure)\n\n**Recommended Implementation:**\n```typescript\ninterface JiraConfig {\n  baseUrl: string;\n  token: string;\n  username?: string;\n}\n\nclass JiraClient {\n  private config: JiraConfig;\n  \n  constructor(config: JiraConfig) {\n    this.config = config;\n  }\n\n  private getHeaders() {\n    return {\n      'Authorization': `Bearer ${this.config.token}`,\n      'Content-Type': 'application/json'\n    };\n  }\n}\n```\n\n## üõ† Phase 2: Core Infrastructure\n\n### 2.1 Project Setup\n\n```bash\nmkdir jira-mcp-server\ncd jira-mcp-server\nnpm init -y\nnpm install @modelcontextprotocol/sdk zod axios\nnpm install -D typescript @types/node\n```\n\n### 2.2 TypeScript Configuration\n\n`tsconfig.json`:\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"es2020\",\n    \"module\": \"commonjs\",\n    \"strict\": true,\n    \"esModuleInterop\": true\n  }\n}\n```\n\n### 2.3 Error Handling Utility\n\n```typescript\nimport { z } from 'zod';\n\nclass JiraApiError extends Error {\n  constructor(\n    public code: string, \n    public details: Record<string, unknown>\n  ) {\n    super(`Jira API Error: ${code}`);\n  }\n\n  toToolResponse() {\n    return {\n      success: false,\n      error: {\n        code: this.code,\n        message: this.message,\n        details: this.details\n      }\n    };\n  }\n}\n\nfunction createErrorHandler() {\n  return {\n    handleApiError(error: any): never {\n      if (error.response) {\n        // Axios error with response\n        throw new JiraApiError(\n          error.response.status.toString(), \n          error.response.data\n        );\n      }\n      throw new JiraApiError('UNKNOWN_ERROR', { \n        originalMessage: error.message \n      });\n    }\n  };\n}\n```\n\n## üß∞ Phase 3: Tool Implementation\n\n### 3.1 Create Issue Tool\n\n```typescript\nimport { z } from 'zod';\nimport axios from 'axios';\n\nconst CreateIssueSchema = z.object({\n  projectKey: z.string().min(1, \"Project key is required\"),\n  summary: z.string().min(1, \"Issue summary is required\"),\n  description: z.string().optional(),\n  issueType: z.string().default(\"Task\")\n});\n\nfunction createIssueTool(client: JiraClient) {\n  return {\n    name: 'jira_create_issue',\n    description: 'Create a new issue in a Jira project',\n    inputSchema: CreateIssueSchema,\n    \n    async execute(input: z.infer<typeof CreateIssueSchema>) {\n      try {\n        const response = await axios.post(\n          `${client.config.baseUrl}/rest/api/3/issue`,\n          {\n            fields: {\n              project: { key: input.projectKey },\n              summary: input.summary,\n              description: input.description,\n              issuetype: { name: input.issueType }\n            }\n          },\n          { headers: client.getHeaders() }\n        );\n\n        return {\n          success: true,\n          issueKey: response.data.key,\n          link: `${client.config.baseUrl}/browse/${response.data.key}`,\n          structuredContent: response.data\n        };\n      } catch (error) {\n        return createErrorHandler().handleApiError(error);\n      }\n    }\n  };\n}\n```\n\n## üß™ Phase 4: Comprehensive Evaluation\n\n### 4.1 Evaluation XML\n\n`jira_evaluations.xml`:\n```xml\n<evaluation>\n  <qa_pair>\n    <question>Create an issue in the 'DEVOPS' project about implementing monitoring for our staging environment, assign it priority 'High', and add a detailed description about key monitoring requirements.</question>\n    <steps>\n      <step>Use jira_create_issue tool</step>\n      <step>Verify issue creation and key details</step>\n    </steps>\n  </qa_pair>\n  \n  <qa_pair>\n    <question>Find all open issues assigned to the current user in the last 7 days across all projects.</question>\n    <steps>\n      <step>Use jira_search_issues tool</step>\n      <step>Apply time and assignment filters</step>\n    </steps>\n  </qa_pair>\n</evaluation>\n```\n\n### 4.2 Evaluation Script\n\n```typescript\nasync function runEvaluations(client: JiraClient) {\n  const tools = {\n    createIssue: createIssueTool(client),\n    // Add other tools here\n  };\n\n  // Load and parse XML\n  // Execute each evaluation scenario\n  // Validate results against expected outcomes\n}\n```\n\n## üîí Security Considerations\n\n1. Use environment variables for sensitive data\n2. Implement rate limiting\n3. Add request timeout\n4. Log errors without exposing sensitive information\n\n## üì¶ Packaging\n\n`package.json`:\n```json\n{\n  \"name\": \"jira-mcp-server\",\n  \"version\": \"1.0.0\",\n  \"main\": \"dist/index.js\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"node dist/index.js\",\n    \"test\": \"npx @modelcontextprotocol/inspector\"\n  }\n}\n```\n\n## üöÄ Recommended Next Steps\n\n1. Implement more tools (search issues, update issues)\n2. Add comprehensive error handling\n3. Create detailed documentation\n4. Set up CI/CD pipeline\n5. Implement logging and monitoring\n\nWould you like me to elaborate on any specific part of the Jira MCP server implementation? I can dive deeper into authentication, tool design, error handling, or evaluation strategies.",
  "verdict": "skill",
  "reasoning": "Response A is significantly better because it correctly understands that the user is asking about building an MCP (Model Context Protocol) server for Jira integration with Claude/AI assistants, not a 'Middleware Control Plane' as Response B incorrectly interprets. Response A provides the correct MCP SDK imports, proper tool schema definitions with Zod validation, authentic MCP server architecture, and includes evaluation XML format specific to MCP testing. Response B, while technically sound as a general web API server, completely misses the mark by building a traditional Express.js server with MongoDB, JWT authentication, and web routes - none of which are relevant to MCP server development. Response A also provides more practical TypeScript implementation with proper error handling specific to MCP tools, while Response B's approach would not work as an MCP server at all.",
  "baseline_tokens": 1858,
  "skill_tokens": 3976,
  "position_a": "skill",
  "position_b": "baseline",
  "judge_model": "claude-sonnet-4-20250514",
  "judged_at": "2026-01-11T18:19:44.752812Z"
}