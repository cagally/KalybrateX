{
  "prompt": "I need to build a complete TypeScript utility class for handling data validation with custom error types and async methods",
  "baseline_response": "Here's a comprehensive TypeScript utility class for data validation with custom error types and async methods:\n\n```typescript\n// Custom Error Types\nclass ValidationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\nclass RequiredFieldError extends ValidationError {\n  constructor(fieldName: string) {\n    super(`Field '${fieldName}' is required`);\n    this.name = 'RequiredFieldError';\n  }\n}\n\nclass TypeMismatchError extends ValidationError {\n  constructor(fieldName: string, expectedType: string) {\n    super(`Field '${fieldName}' must be of type ${expectedType}`);\n    this.name = 'TypeMismatchError';\n  }\n}\n\n// Validation Interfaces\ninterface ValidationRule {\n  validate(value: any): boolean | Promise<boolean>;\n}\n\ninterface ValidationOptions {\n  required?: boolean;\n  type?: 'string' | 'number' | 'boolean' | 'object' | 'array';\n  minLength?: number;\n  maxLength?: number;\n  pattern?: RegExp;\n  custom?: (value: any) => boolean | Promise<boolean>;\n}\n\n// Validation Utility Class\nclass Validator {\n  // Synchronous validation method\n  static validate(\n    value: any, \n    options: ValidationOptions = {}\n  ): boolean {\n    // Check required field\n    if (options.required && (value === null || value === undefined)) {\n      throw new RequiredFieldError('Field');\n    }\n\n    // Type checking\n    if (options.type) {\n      switch (options.type) {\n        case 'string':\n          if (typeof value !== 'string') {\n            throw new TypeMismatchError('Field', 'string');\n          }\n          break;\n        case 'number':\n          if (typeof value !== 'number') {\n            throw new TypeMismatchError('Field', 'number');\n          }\n          break;\n        case 'boolean':\n          if (typeof value !== 'boolean') {\n            throw new TypeMismatchError('Field', 'boolean');\n          }\n          break;\n        case 'object':\n          if (typeof value !== 'object' || value === null) {\n            throw new TypeMismatchError('Field', 'object');\n          }\n          break;\n        case 'array':\n          if (!Array.isArray(value)) {\n            throw new TypeMismatchError('Field', 'array');\n          }\n          break;\n      }\n    }\n\n    // String-specific validations\n    if (typeof value === 'string') {\n      // Min length\n      if (options.minLength !== undefined && value.length < options.minLength) {\n        throw new ValidationError(`Minimum length is ${options.minLength}`);\n      }\n\n      // Max length\n      if (options.maxLength !== undefined && value.length > options.maxLength) {\n        throw new ValidationError(`Maximum length is ${options.maxLength}`);\n      }\n\n      // Regex pattern\n      if (options.pattern && !options.pattern.test(value)) {\n        throw new ValidationError('Invalid format');\n      }\n    }\n\n    // Custom validation\n    if (options.custom) {\n      const customResult = options.custom(value);\n      if (customResult === false) {\n        throw new ValidationError('Custom validation failed');\n      }\n    }\n\n    return true;\n  }\n\n  // Asynchronous validation method\n  static async validateAsync(\n    value: any, \n    options: ValidationOptions = {}\n  ): Promise<boolean> {\n    try {\n      // Perform synchronous validations first\n      this.validate(value, options);\n\n      // Handle async custom validation\n      if (options.custom) {\n        const customResult = options.custom(value);\n        \n        // If custom validation returns a promise\n        if (customResult instanceof Promise) {\n          return await customResult;\n        }\n\n        return customResult;\n      }\n\n      return true;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  // Schema validation method\n  static validateSchema<T>(\n    data: T, \n    schema: { [K in keyof T]: ValidationOptions }\n  ): boolean {\n    for (const [key, rules] of Object.entries(schema)) {\n      this.validate((data as any)[key], rules);\n    }\n    return true;\n  }\n\n  // Async schema validation method\n  static async validateSchemaAsync<T>(\n    data: T, \n    schema: { [K in keyof T]: ValidationOptions }\n  ): Promise<boolean> {\n    for (const [key, rules] of Object.entries(schema)) {\n      await this.validateAsync((data as any)[key], rules);\n    }\n    return true;\n  }\n}\n\n// Example Usage\nasync function exampleUsage() {\n  // Synchronous Validation\n  try {\n    // Basic required string validation\n    Validator.validate('test', { \n      required: true, \n      type: 'string', \n      minLength: 2, \n      maxLength: 10 \n    });\n\n    // Custom validation\n    Validator.validate(25, {\n      type: 'number',\n      custom: (value) => value > 20\n    });\n  } catch (error) {\n    if (error instanceof ValidationError) {\n      console.error(error.message);\n    }\n  }\n\n  // Asynchronous Validation\n  try {\n    // Async custom validation\n    await Validator.validateAsync('example', {\n      custom: async (value) => {\n        // Simulate async operation\n        await new Promise(resolve => setTimeout(resolve, 100));\n        return value.length > 3;\n      }\n    });\n\n    // Schema Validation\n    const userSchema = {\n      username: { \n        required: true, \n        type: 'string', \n        minLength: 3, \n        maxLength: 20 \n      },\n      age: { \n        required: true, \n        type: 'number', \n        custom: (value) => value >= 18 \n      }\n    };\n\n    const userData = {\n      username: 'johndoe',\n      age: 25\n    };\n\n    // Synchronous schema validation\n    Validator.validateSchema(userData, userSchema);\n\n    // Async schema validation\n    await Validator.validateSchemaAsync(userData, userSchema);\n  } catch (error) {\n    console.error(error);\n  }\n}\n```\n\nThis comprehensive validation utility provides:\n\n1. Custom Error Types\n- `ValidationError`: Base error for validation\n- `RequiredFieldError`: For missing required fields\n- `TypeMismatchError`: For type mismatches\n\n2. Validation Methods\n- `validate()`: Synchronous validation\n- `validateAsync()`: Asynchronous validation\n- `validateSchema()`: Synchronous schema validation\n- `validateSchemaAsync()`: Asynchronous schema validation\n\n3. Validation Options\n- `required`: Ensure field is not null/undefined\n- `type`: Specify expected data type\n- `minLength`/`maxLength`: String length constraints\n- `pattern`: Regex validation\n- `custom`: Custom validation function (sync/async)\n\nKey Features:\n- Supports both synchronous and asynchronous validation\n- Flexible schema validation\n- Detailed error handling\n- Supports various data types\n- Custom validation capabilities\n\nUsage Examples:\n- Basic field validation\n- Complex schema validation\n- Async validations\n- Custom validation logic\n\nYou can extend this class further by adding more specific validation methods or error types as needed for your project.",
  "skill_response": "I'll help you create a comprehensive TypeScript utility class for data validation with advanced features. Here's a robust implementation:\n\n```typescript\n// ValidationError.ts\nexport class ValidationError extends Error {\n  public readonly validationErrors: Record<string, string[]>;\n\n  constructor(errors: Record<string, string[]>) {\n    super('Validation failed');\n    this.name = 'ValidationError';\n    this.validationErrors = errors;\n    \n    // Ensures proper prototype chain for instanceof checks\n    Object.setPrototypeOf(this, ValidationError.prototype);\n  }\n\n  // Convenient method to get all errors\n  getAllErrorMessages(): string[] {\n    return Object.values(this.validationErrors).flat();\n  }\n}\n\n// ValidationRule.ts\nexport type ValidationRule<T> = (value: T) => string | null;\n\n// DataValidator.ts\nexport class DataValidator<T> {\n  private data: T;\n  private rules: Record<keyof T, ValidationRule<any>[]>;\n\n  constructor(data: T, rules?: Record<keyof T, ValidationRule<any>[]>) {\n    this.data = data;\n    this.rules = rules || {} as Record<keyof T, ValidationRule<any>[]>;\n  }\n\n  // Add validation rule for a specific field\n  addRule(field: keyof T, rule: ValidationRule<any>): this {\n    if (!this.rules[field]) {\n      this.rules[field] = [];\n    }\n    this.rules[field].push(rule);\n    return this;\n  }\n\n  // Validate synchronously\n  validate(): void {\n    const errors: Record<string, string[]> = {};\n\n    Object.keys(this.rules).forEach((field) => {\n      const fieldRules = this.rules[field as keyof T];\n      const value = this.data[field as keyof T];\n      \n      const fieldErrors = fieldRules\n        .map(rule => rule(value))\n        .filter((error): error is string => error !== null);\n\n      if (fieldErrors.length > 0) {\n        errors[field] = fieldErrors;\n      }\n    });\n\n    if (Object.keys(errors).length > 0) {\n      throw new ValidationError(errors);\n    }\n  }\n\n  // Async validation\n  async validateAsync(): Promise<void> {\n    const errors: Record<string, string[]> = {};\n\n    for (const field of Object.keys(this.rules)) {\n      const fieldRules = this.rules[field as keyof T];\n      const value = this.data[field as keyof T];\n      \n      const fieldErrors: string[] = [];\n      \n      for (const rule of fieldRules) {\n        const error = await Promise.resolve(rule(value));\n        if (error !== null) {\n          fieldErrors.push(error);\n        }\n      }\n\n      if (fieldErrors.length > 0) {\n        errors[field] = fieldErrors;\n      }\n    }\n\n    if (Object.keys(errors).length > 0) {\n      throw new ValidationError(errors);\n    }\n  }\n\n  // Preset validation rules\n  static rules = {\n    required: <T>(errorMessage = 'Field is required'): ValidationRule<T> => \n      (value) => value === null || value === undefined || value === '' ? errorMessage : null,\n\n    minLength: (min: number, errorMessage?: string): ValidationRule<string> => \n      (value) => (value || '').length < min \n        ? errorMessage || `Minimum length is ${min} characters` \n        : null,\n\n    maxLength: (max: number, errorMessage?: string): ValidationRule<string> => \n      (value) => (value || '').length > max \n        ? errorMessage || `Maximum length is ${max} characters` \n        : null,\n\n    email: (errorMessage = 'Invalid email format'): ValidationRule<string> => \n      (value) => {\n        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n        return value && !emailRegex.test(value) ? errorMessage : null;\n      },\n\n    numeric: (errorMessage = 'Must be a number'): ValidationRule<any> => \n      (value) => isNaN(Number(value)) ? errorMessage : null,\n\n    custom: <T>(\n      validationFn: (value: T) => boolean, \n      errorMessage = 'Validation failed'\n    ): ValidationRule<T> => \n      (value) => validationFn(value) ? null : errorMessage\n  };\n}\n\n// Example Usage\ninterface UserData {\n  name: string;\n  email: string;\n  age: number;\n}\n\nasync function exampleValidation() {\n  try {\n    const userData: UserData = {\n      name: 'John',\n      email: 'john@example.com',\n      age: 25\n    };\n\n    const validator = new DataValidator<UserData>(userData)\n      .addRule('name', DataValidator.rules.required())\n      .addRule('name', DataValidator.rules.minLength(2))\n      .addRule('email', DataValidator.rules.required())\n      .addRule('email', DataValidator.rules.email())\n      .addRule('age', DataValidator.rules.numeric());\n\n    // Synchronous validation\n    validator.validate();\n\n    // Or async validation\n    await validator.validateAsync();\n\n    console.log('Validation passed!');\n  } catch (error) {\n    if (error instanceof ValidationError) {\n      console.error('Validation failed:', error.validationErrors);\n      console.error('All error messages:', error.getAllErrorMessages());\n    }\n  }\n}\n```\n\nKey Features:\n1. Custom `ValidationError` with detailed error tracking\n2. Supports both sync and async validation\n3. Flexible rule addition\n4. Preset validation rules (required, length, email, etc.)\n5. Custom rule creation\n6. Type-safe generic implementation\n\nUsage Example:\n```typescript\n// Basic validation\nconst validator = new DataValidator<UserData>(userData)\n  .addRule('name', DataValidator.rules.required())\n  .addRule('email', DataValidator.rules.email());\n\n// Custom rule\nvalidator.addRule('age', DataValidator.rules.custom(\n  (value) => value >= 18, \n  'Must be 18 or older'\n));\n```\n\nThis implementation provides a robust, flexible, and type-safe approach to data validation in TypeScript, with support for complex validation scenarios and custom error handling.",
  "verdict": "skill",
  "reasoning": "Response B provides a more sophisticated and production-ready implementation. Key advantages include: 1) Better error handling with structured validation errors that track multiple errors per field, 2) More flexible architecture with chainable rule addition and generic type safety, 3) Cleaner separation of concerns with proper TypeScript interfaces, 4) More robust async validation that properly handles promises, 5) Better extensibility with preset rules and custom rule creation, 6) Proper prototype chain handling for instanceof checks. While Response A covers the basics adequately, Response B demonstrates advanced TypeScript patterns, better error aggregation, and a more maintainable design that would scale better in real applications.",
  "baseline_tokens": 1873,
  "skill_tokens": 1683,
  "position_a": "baseline",
  "position_b": "skill",
  "judge_model": "claude-sonnet-4-20250514",
  "judged_at": "2026-01-11T18:58:21.143223Z"
}