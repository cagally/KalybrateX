{
  "prompt": "I need to add proper error handling to my MCP server tools so that when the external API fails, the AI gets helpful information about what went wrong and how to fix it.",
  "baseline_response": "Here's a comprehensive approach to error handling for API interactions in Python:\n\n```python\nimport requests\nimport logging\nfrom typing import Dict, Any, Optional\n\nclass APIError(Exception):\n    \"\"\"Custom exception for API-related errors\"\"\"\n    def __init__(self, message: str, status_code: Optional[int] = None, \n                 response_text: Optional[str] = None):\n        self.message = message\n        self.status_code = status_code\n        self.response_text = response_text\n        super().__init__(self.detailed_message())\n\n    def detailed_message(self) -> str:\n        \"\"\"Generate a comprehensive error message\"\"\"\n        details = [self.message]\n        if self.status_code:\n            details.append(f\"Status Code: {self.status_code}\")\n        if self.response_text:\n            details.append(f\"Response: {self.response_text}\")\n        return \" | \".join(details)\n\ndef handle_api_request(\n    method: str, \n    url: str, \n    headers: Optional[Dict[str, str]] = None,\n    params: Optional[Dict[str, Any]] = None,\n    data: Optional[Dict[str, Any]] = None,\n    timeout: int = 30\n) -> Dict[str, Any]:\n    \"\"\"\n    Centralized API request handler with robust error management\n    \n    Args:\n        method: HTTP method (get, post, etc.)\n        url: API endpoint URL\n        headers: Optional request headers\n        params: Optional query parameters\n        data: Optional request payload\n        timeout: Request timeout in seconds\n    \n    Returns:\n        Parsed JSON response\n    \n    Raises:\n        APIError for various connection and API-related issues\n    \"\"\"\n    # Configure logging\n    logging.basicConfig(level=logging.INFO)\n    logger = logging.getLogger(__name__)\n\n    # Default headers\n    headers = headers or {}\n    headers.setdefault('Content-Type', 'application/json')\n\n    try:\n        # Select appropriate request method\n        request_method = getattr(requests, method.lower())\n        \n        # Execute API request\n        response = request_method(\n            url, \n            headers=headers, \n            params=params, \n            json=data, \n            timeout=timeout\n        )\n\n        # Check for HTTP errors\n        response.raise_for_status()\n\n        # Parse and return response\n        return response.json()\n\n    except requests.exceptions.ConnectionError as e:\n        # Network connectivity issues\n        logger.error(f\"Network Connection Error: {e}\")\n        raise APIError(\"Unable to connect to the API. Check network connectivity.\", \n                       response_text=str(e))\n\n    except requests.exceptions.Timeout as e:\n        # Request timeout\n        logger.error(f\"API Request Timeout: {e}\")\n        raise APIError(\"API request timed out. The server might be overloaded.\", \n                       response_text=str(e))\n\n    except requests.exceptions.HTTPError as e:\n        # HTTP status code errors\n        response = e.response\n        error_details = {\n            400: \"Bad Request: Check your input parameters\",\n            401: \"Unauthorized: Verify your authentication credentials\",\n            403: \"Forbidden: You lack necessary permissions\",\n            404: \"Not Found: The requested resource doesn't exist\",\n            500: \"Internal Server Error: API service is experiencing issues\",\n            502: \"Bad Gateway: API upstream service is down\",\n            503: \"Service Unavailable: API is temporarily overloaded\"\n        }\n\n        default_message = f\"HTTP Error occurred: {response.status_code}\"\n        specific_message = error_details.get(response.status_code, default_message)\n\n        logger.error(f\"HTTP Error: {specific_message}\")\n        raise APIError(\n            specific_message, \n            status_code=response.status_code, \n            response_text=response.text\n        )\n\n    except requests.exceptions.RequestException as e:\n        # Catch-all for other request-related exceptions\n        logger.error(f\"Unexpected API Request Error: {e}\")\n        raise APIError(\"An unexpected error occurred during the API request.\", \n                       response_text=str(e))\n\n    except ValueError as e:\n        # JSON parsing errors\n        logger.error(f\"JSON Parsing Error: {e}\")\n        raise APIError(\"Failed to parse API response. Response may be malformed.\", \n                       response_text=str(e))\n\n# Example usage\ndef main():\n    try:\n        # Example API call\n        api_response = handle_api_request(\n            'get', \n            'https://api.example.com/data',\n            headers={'Authorization': 'Bearer token123'}\n        )\n        print(api_response)\n\n    except APIError as e:\n        # Centralized error handling\n        print(f\"API Error Occurred: {e}\")\n        # Potentially trigger recovery or notification mechanisms\n\nif __name__ == \"__main__\":\n    main()\n```\n\nKey Features:\n1. Comprehensive error handling\n2. Detailed error messages\n3. Logging support\n4. Custom exception with rich context\n5. Handles various network and HTTP scenarios\n6. Provides actionable error information\n\nRecommended Enhancements:\n- Implement retry mechanisms\n- Add authentication refresh logic\n- Create specific error subclasses for more granular handling\n- Integrate with monitoring/alerting systems\n\nBest Practices:\n- Log errors with sufficient context\n- Provide user-friendly error messages\n- Include technical details for debugging\n- Implement graceful error recovery\n\nThis approach gives you a robust, flexible error handling framework for API interactions.\n\nWould you like me to elaborate on any specific aspect of error handling?",
  "skill_response": "Here's a comprehensive approach to error handling in MCP server tools that provides meaningful, actionable feedback:\n\n```typescript\n// ErrorHandling Strategy for MCP Tools\n\nimport { z } from 'zod';\nimport { MCPToolError } from '@modelcontextprotocol/sdk';\n\n// Define a structured error response\ninterface DetailedErrorResponse {\n  type: 'AUTH_ERROR' | 'RATE_LIMIT' | 'NETWORK_ERROR' | 'VALIDATION_ERROR' | 'UNKNOWN_ERROR';\n  message: string;\n  suggestedFix?: string;\n  retryAfter?: number; // milliseconds\n}\n\nfunction createDetailedError(error: any): DetailedErrorResponse {\n  // Categorize and transform external API errors into structured, helpful responses\n  if (error.response?.status === 401) {\n    return {\n      type: 'AUTH_ERROR',\n      message: 'Authentication failed with the external service',\n      suggestedFix: 'Check your API credentials. They may be expired or incorrect.',\n      retryAfter: 0 // Immediate action required\n    };\n  }\n\n  if (error.response?.status === 429) {\n    return {\n      type: 'RATE_LIMIT',\n      message: 'Rate limit exceeded for the external API',\n      suggestedFix: 'Wait before making additional requests. Consider implementing exponential backoff.',\n      retryAfter: error.response.headers['retry-after'] * 1000 || 60000 // Default 1 minute\n    };\n  }\n\n  if (error.code === 'ECONNREFUSED' || error.code === 'ETIMEDOUT') {\n    return {\n      type: 'NETWORK_ERROR',\n      message: 'Could not connect to the external service',\n      suggestedFix: 'Check your network connection and the service status. The service might be temporarily unavailable.',\n      retryAfter: 30000 // Suggest waiting 30 seconds\n    };\n  }\n\n  // Validation errors from input\n  if (error instanceof z.ZodError) {\n    return {\n      type: 'VALIDATION_ERROR',\n      message: 'Input validation failed',\n      suggestedFix: error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join('; ')\n    };\n  }\n\n  // Fallback for unknown errors\n  return {\n    type: 'UNKNOWN_ERROR',\n    message: error.message || 'An unexpected error occurred',\n    suggestedFix: 'Review the error details and contact support if the issue persists.'\n  };\n}\n\n// Example tool with comprehensive error handling\nasync function searchRepositories(params: {\n  query: string,\n  language?: string\n}) {\n  const inputSchema = z.object({\n    query: z.string().min(1, \"Search query must not be empty\"),\n    language: z.string().optional()\n  });\n\n  try {\n    // Validate input\n    const validatedParams = inputSchema.parse(params);\n\n    // Attempt API call\n    const results = await githubApiClient.searchRepositories(validatedParams);\n\n    // Return structured response\n    return {\n      content: `Found ${results.totalCount} repositories matching the query.`,\n      structuredContent: results\n    };\n  } catch (error) {\n    // Transform error into structured, helpful response\n    const detailedError = createDetailedError(error);\n\n    // Throw an MCP-compatible error that provides context\n    throw new MCPToolError({\n      message: detailedError.message,\n      details: {\n        type: detailedError.type,\n        suggestedFix: detailedError.suggestedFix,\n        retryAfter: detailedError.retryAfter\n      }\n    });\n}\n\n// Example usage in tool registration\nserver.registerTool({\n  name: 'github_search_repositories',\n  description: 'Search GitHub repositories with advanced filtering',\n  inputSchema: z.object({\n    query: z.string(),\n    language: z.string().optional()\n  }),\n  handler: searchRepositories,\n  errorHandling: {\n    // Optional: Additional global error handling configuration\n    maxRetries: 3,\n    retryStrategy: 'exponential'\n  }\n});\n```\n\nKey Error Handling Principles:\n\n1. **Structured Error Responses**\n   - Create a consistent error structure\n   - Include error type, message, and suggested fix\n   - Provide retry information when possible\n\n2. **Input Validation**\n   - Use Zod (TypeScript) or Pydantic (Python) for robust input validation\n   - Provide clear, specific validation error messages\n\n3. **Comprehensive Error Categorization**\n   - Authentication errors\n   - Rate limiting\n   - Network issues\n   - Validation errors\n   - Unknown errors\n\n4. **Actionable Feedback**\n   - Each error includes a `suggestedFix`\n   - Provides clear guidance for resolution\n\n5. **MCP-Compatible Error Throwing**\n   - Use `MCPToolError` to ensure compatibility\n   - Include structured error details\n\nBest Practices:\n- Always validate inputs before making API calls\n- Transform external API errors into consistent, helpful responses\n- Provide actionable suggestions\n- Include retry information when possible\n- Log detailed error information server-side\n\nAdditional Recommendations:\n- Implement logging for all errors\n- Consider adding telemetry for error tracking\n- Create a centralized error handling utility\n\nThis approach ensures that when an AI attempts to use your MCP server tool and encounters an error, it receives clear, actionable information about what went wrong and how to potentially resolve the issue.",
  "verdict": "skill",
  "reasoning": "Response A is significantly better because it directly addresses MCP (Model Context Protocol) server tools, which is exactly what the user asked about. It provides TypeScript code with MCP-specific imports, proper MCPToolError usage, and structured error handling designed for AI interactions. Response A includes actionable error categorization with suggestedFix fields and retryAfter timing - crucial for AI agents to understand how to proceed. Response B, while well-written, provides generic Python API error handling that doesn't address MCP servers or AI-specific error communication patterns. Response A is more relevant, practical, and complete for the user's specific MCP server context.",
  "baseline_tokens": 1399,
  "skill_tokens": 3642,
  "position_a": "skill",
  "position_b": "baseline",
  "judge_model": "claude-sonnet-4-20250514",
  "judged_at": "2026-01-11T18:15:06.865625Z"
}