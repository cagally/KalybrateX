{
  "prompt": "My documentation page has some DOM manipulation examples that use document.createElement and event listeners. I need tests for these but I'm not sure how to set up the DOM testing environment properly.",
  "baseline_response": "Here's a comprehensive approach to testing DOM manipulation with JavaScript, using Jest and Testing Library:\n\n```javascript\n// Example DOM manipulation function to test\nfunction createListItem(text) {\n  const li = document.createElement('li');\n  li.textContent = text;\n  li.classList.add('list-item');\n  li.addEventListener('click', () => {\n    li.classList.toggle('selected');\n  });\n  return li;\n}\n\n// Test suite for DOM manipulation\ndescribe('DOM Manipulation Tests', () => {\n  // Setup and teardown for DOM testing\n  let container;\n\n  beforeEach(() => {\n    // Create a fresh DOM container for each test\n    container = document.createElement('div');\n    document.body.appendChild(container);\n  });\n\n  afterEach(() => {\n    // Clean up the DOM after each test\n    document.body.removeChild(container);\n  });\n\n  test('creates list item with correct text and class', () => {\n    const itemText = 'Test Item';\n    const listItem = createListItem(itemText);\n\n    // Append to container for testing\n    container.appendChild(listItem);\n\n    // Check text content\n    expect(listItem.textContent).toBe(itemText);\n    \n    // Check initial classes\n    expect(listItem.classList.contains('list-item')).toBe(true);\n  });\n\n  test('toggles selected class on click', () => {\n    const listItem = createListItem('Clickable Item');\n    container.appendChild(listItem);\n\n    // Simulate click\n    listItem.click();\n\n    // Check class was added\n    expect(listItem.classList.contains('selected')).toBe(true);\n\n    // Simulate second click\n    listItem.click();\n\n    // Check class was removed\n    expect(listItem.classList.contains('selected')).toBe(false);\n  });\n});\n\n// More complex example with event handling\nfunction createInteractiveButton() {\n  const button = document.createElement('button');\n  button.textContent = 'Click Me';\n  \n  let clickCount = 0;\n  button.addEventListener('click', (event) => {\n    clickCount++;\n    button.dataset.clicks = clickCount;\n  });\n\n  return button;\n}\n\ndescribe('Interactive Button Tests', () => {\n  let container;\n\n  beforeEach(() => {\n    container = document.createElement('div');\n    document.body.appendChild(container);\n  });\n\n  afterEach(() => {\n    document.body.removeChild(container);\n  });\n\n  test('increments click count on click', () => {\n    const button = createInteractiveButton();\n    container.appendChild(button);\n\n    // Simulate multiple clicks\n    button.click();\n    button.click();\n    button.click();\n\n    // Check click count in dataset\n    expect(button.dataset.clicks).toBe('3');\n  });\n});\n\n// Testing with user events (more modern approach)\nimport { render, fireEvent } from '@testing-library/react';\n// or for vanilla JS\nimport { fireEvent } from '@testing-library/dom';\n\ndescribe('Advanced DOM Interaction', () => {\n  test('simulates user interactions more precisely', () => {\n    const button = createInteractiveButton();\n    document.body.appendChild(button);\n\n    // More robust event simulation\n    fireEvent.click(button);\n    fireEvent.click(button);\n\n    expect(button.dataset.clicks).toBe('2');\n  });\n});\n```\n\nKey Testing Strategies:\n1. Use `beforeEach()` and `afterEach()` to set up and clean up the DOM\n2. Create a container to isolate test DOM elements\n3. Test element creation, content, and classes\n4. Simulate events and check resulting state\n5. Use different testing approaches (native click vs. fireEvent)\n\nSetup for Jest DOM Testing:\n```bash\n# Install dependencies\nnpm install --save-dev jest @testing-library/jest-dom @testing-library/dom\n```\n\nJest Config (jest.config.js):\n```javascript\nmodule.exports = {\n  testEnvironment: 'jsdom',\n  setupFilesAfterEnv: ['@testing-library/jest-dom/extend-expect']\n};\n```\n\npackage.json script:\n```json\n{\n  \"scripts\": {\n    \"test\": \"jest\"\n  }\n}\n```\n\nAdditional Tips:\n- Use `jest-dom` for extended assertions\n- Simulate real user interactions\n- Test both creation and interaction of DOM elements\n- Clean up DOM between tests to prevent state leakage\n\nCommon Assertions:\n```javascript\n// Check element exists\nexpect(element).toBeTruthy();\n\n// Check text content\nexpect(element.textContent).toBe('Expected Text');\n\n// Check classes\nexpect(element.classList.contains('class-name')).toBe(true);\n\n// Check attributes\nexpect(element.getAttribute('data-testid')).toBe('expected-value');\n```\n\nThis approach provides a robust way to test DOM manipulation, covering element creation, event handling, and state changes.",
  "skill_response": "I'll provide a comprehensive guide for testing DOM manipulation examples with Vitest and jsdom. I'll break this down into a step-by-step approach with multiple example patterns.\n\n### Basic DOM Test File Setup\n\n```javascript\n/**\n * @vitest-environment jsdom\n */\nimport { describe, it, expect, beforeEach, afterEach } from 'vitest'\n\ndescribe('DOM Manipulation Examples', () => {\n  let container\n\n  beforeEach(() => {\n    // Create a fresh container for each test\n    container = document.createElement('div')\n    document.body.appendChild(container)\n  })\n\n  afterEach(() => {\n    // Clean up the DOM after each test\n    document.body.innerHTML = ''\n  })\n\n  // Your DOM tests will go here\n})\n```\n\n### Pattern 1: Element Creation and Manipulation\n\n**Documentation Example:**\n```javascript\nconst div = document.createElement('div')\ndiv.textContent = 'Hello, World!'\ndiv.classList.add('greeting')\ndocument.body.appendChild(div)\n```\n\n**Corresponding Test:**\n```javascript\nit('should create and manipulate an element', () => {\n  const div = document.createElement('div')\n  div.textContent = 'Hello, World!'\n  div.classList.add('greeting')\n  container.appendChild(div)\n\n  // Verify element creation\n  const createdElement = container.querySelector('.greeting')\n  expect(createdElement).not.toBeNull()\n  expect(createdElement.textContent).toBe('Hello, World!')\n  expect(createdElement.classList.contains('greeting')).toBe(true)\n})\n```\n\n### Pattern 2: Event Listener Testing\n\n**Documentation Example:**\n```javascript\nconst button = document.createElement('button')\nbutton.textContent = 'Click me'\nlet clickCount = 0\n\nbutton.addEventListener('click', () => {\n  clickCount++\n})\n\ndocument.body.appendChild(button)\nbutton.click()\n```\n\n**Corresponding Test:**\n```javascript\nit('should handle click events', () => {\n  const button = document.createElement('button')\n  button.textContent = 'Click me'\n  let clickCount = 0\n\n  button.addEventListener('click', () => {\n    clickCount++\n  })\n\n  container.appendChild(button)\n  \n  // Simulate click\n  button.click()\n\n  expect(clickCount).toBe(1)\n})\n```\n\n### Pattern 3: Complex Event Interaction\n\n**Documentation Example:**\n```javascript\nconst input = document.createElement('input')\nconst output = document.createElement('div')\n\ninput.addEventListener('input', (event) => {\n  output.textContent = `You typed: ${event.target.value}`\n})\n\ndocument.body.appendChild(input)\ndocument.body.appendChild(output)\n\n// Simulate user typing\ninput.value = 'Hello'\ninput.dispatchEvent(new Event('input'))\n```\n\n**Corresponding Test:**\n```javascript\nit('should update output on input event', () => {\n  const input = document.createElement('input')\n  const output = document.createElement('div')\n\n  input.addEventListener('input', (event) => {\n    output.textContent = `You typed: ${event.target.value}`\n  })\n\n  container.appendChild(input)\n  container.appendChild(output)\n\n  // Simulate user input\n  input.value = 'Hello'\n  input.dispatchEvent(new Event('input'))\n\n  expect(output.textContent).toBe('You typed: Hello')\n})\n```\n\n### Pattern 4: Multiple Event Listeners\n\n**Documentation Example:**\n```javascript\nconst button = document.createElement('button')\nlet clickCount = 0\nlet lastEvent = null\n\nbutton.addEventListener('click', (event) => {\n  clickCount++\n  lastEvent = event.type\n})\n\nbutton.addEventListener('mouseenter', (event) => {\n  lastEvent = event.type\n})\n\ndocument.body.appendChild(button)\n```\n\n**Corresponding Test:**\n```javascript\nit('should support multiple event listeners', () => {\n  const button = document.createElement('button')\n  let clickCount = 0\n  let lastEvent = null\n\n  button.addEventListener('click', (event) => {\n    clickCount++\n    lastEvent = event.type\n  })\n\n  button.addEventListener('mouseenter', (event) => {\n    lastEvent = event.type\n  })\n\n  container.appendChild(button)\n\n  // Simulate events\n  button.click()\n  expect(clickCount).toBe(1)\n  expect(lastEvent).toBe('click')\n\n  button.dispatchEvent(new Event('mouseenter'))\n  expect(lastEvent).toBe('mouseenter')\n})\n```\n\n### Advanced: Mocking Event Methods\n\n```javascript\nit('should mock event methods', () => {\n  const mockPreventDefault = vi.fn()\n  const mockStopPropagation = vi.fn()\n\n  const event = {\n    preventDefault: mockPreventDefault,\n    stopPropagation: mockStopPropagation\n  }\n\n  const handler = (e) => {\n    e.preventDefault()\n    e.stopPropagation()\n  }\n\n  handler(event)\n\n  expect(mockPreventDefault).toHaveBeenCalled()\n  expect(mockStopPropagation).toHaveBeenCalled()\n})\n```\n\n### Best Practices\n\n1. **Always use `@vitest-environment jsdom`**\n2. **Create and clean up a container for each test**\n3. **Use `dispatchEvent()` to simulate user interactions**\n4. **Test both the result and the process**\n5. **Mock complex interactions when necessary**\n\n### Troubleshooting Tips\n\n- If tests fail, ensure you're using `@vitest-environment jsdom`\n- Check that you're cleaning up the DOM between tests\n- Use `console.log()` or debugger to inspect the DOM state\n\n### Running DOM Tests\n\n```bash\n# Run all DOM tests\nnpm test -- --environment=jsdom\n\n# Run specific DOM test file\nnpm test -- path/to/your/dom.test.js\n```\n\nThis comprehensive approach covers various DOM manipulation scenarios, providing robust testing for your documentation's code examples. The key is to simulate user interactions and verify both the DOM state and event handling.",
  "verdict": "skill",
  "reasoning": "Response A is significantly better because it directly addresses the user's specific context with Vitest and jsdom configuration, providing the exact `@vitest-environment jsdom` directive needed. It offers comprehensive, well-structured examples that mirror real documentation patterns with corresponding tests, includes advanced patterns like event mocking, and provides practical troubleshooting tips. Response B, while technically sound, assumes Jest/Testing Library setup without matching the user's implied Vitest context, uses more complex tooling that may be overkill, and doesn't provide the same level of practical, immediately actionable guidance for DOM testing setup.",
  "baseline_tokens": 1239,
  "skill_tokens": 7790,
  "position_a": "skill",
  "position_b": "baseline",
  "judge_model": "claude-sonnet-4-20250514",
  "judged_at": "2026-01-11T18:37:54.549365Z"
}