{
  "prompt": "Can you write a JavaScript function that debounces API calls and handles loading states?",
  "baseline_response": "Here's a comprehensive JavaScript function that implements debouncing for API calls with loading state management:\n\n```javascript\n/**\n * Debounce function for API calls with loading state management\n * @param {Function} apiCall - The API call function to be debounced\n * @param {number} delay - Delay in milliseconds\n * @returns {Function} Debounced function with loading state management\n */\nfunction createDebouncedApiCall(apiCall, delay = 300) {\n  let timeoutId = null;\n  \n  // Create a state object to track loading and error states\n  const state = {\n    isLoading: false,\n    error: null,\n    data: null,\n    cancel: () => {}\n  };\n\n  /**\n   * Debounced API call wrapper\n   * @param {...*} args - Arguments to pass to the API call\n   * @returns {Promise} Promise resolving with API response\n   */\n  function debouncedApiCall(...args) {\n    // Clear any existing timeout\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n\n    // Reset state\n    state.isLoading = true;\n    state.error = null;\n    state.data = null;\n\n    // Create a cancellation token\n    const controller = new AbortController();\n    state.cancel = () => controller.abort();\n\n    // Return a new promise that resolves after debounce delay\n    return new Promise((resolve, reject) => {\n      timeoutId = setTimeout(async () => {\n        try {\n          // Merge signal with existing args if apiCall supports it\n          const finalArgs = args.concat({ signal: controller.signal });\n          \n          // Perform the API call\n          const result = await apiCall(...finalArgs);\n          \n          // Update state with successful response\n          state.isLoading = false;\n          state.data = result;\n          \n          resolve(result);\n        } catch (error) {\n          // Handle cancellation and other errors\n          if (error.name === 'AbortError') {\n            console.log('API call cancelled');\n          } else {\n            // Update state with error\n            state.isLoading = false;\n            state.error = error;\n            \n            reject(error);\n          }\n        }\n      }, delay);\n    });\n  }\n\n  // Attach state to the debounced function\n  debouncedApiCall.state = state;\n\n  return debouncedApiCall;\n}\n\n// Example usage\n// Simulated API call function\nasync function fetchUserData(userId, options = {}) {\n  const { signal } = options;\n  \n  return new Promise((resolve, reject) => {\n    // Simulate network request\n    const timeout = setTimeout(() => {\n      if (signal?.aborted) {\n        reject(new DOMException('Aborted', 'AbortError'));\n      } else {\n        resolve({ \n          id: userId, \n          name: `User ${userId}`, \n          timestamp: Date.now() \n        });\n      }\n    }, 1000);\n\n    // Allow cancellation\n    signal?.addEventListener('abort', () => {\n      clearTimeout(timeout);\n      reject(new DOMException('Aborted', 'AbortError'));\n    });\n  });\n}\n\n// Create a debounced API call\nconst debouncedFetchUser = createDebouncedApiCall(fetchUserData, 300);\n\n// Usage in a component or application\nasync function handleUserSearch(userId) {\n  try {\n    // Check loading state before call\n    if (debouncedFetchUser.state.isLoading) {\n      // Optional: Cancel previous call\n      debouncedFetchUser.state.cancel();\n    }\n\n    // Perform debounced API call\n    const userData = await debouncedFetchUser(userId);\n    console.log('User data:', userData);\n  } catch (error) {\n    console.error('Error fetching user:', error);\n  }\n}\n\n// Example of tracking loading state\nfunction trackApiCall() {\n  handleUserSearch(123);\n\n  // Check loading state\n  console.log('Is Loading:', debouncedFetchUser.state.isLoading);\n  \n  // Access error or data if available\n  console.log('Error:', debouncedFetchUser.state.error);\n  console.log('Data:', debouncedFetchUser.state.data);\n}\n```\n\nThis implementation provides several advanced features:\n\n1. **Debouncing**: Delays API calls to reduce unnecessary network requests\n2. **Loading State Management**: Tracks `isLoading`, `error`, and `data` states\n3. **Cancellation Support**: Allows cancelling in-flight requests\n4. **Flexible API Call Handling**: Works with various API call signatures\n5. **Error Handling**: Captures and manages different types of errors\n6. **TypeScript-friendly**: Can be easily adapted for TypeScript projects\n\nKey Features:\n- Configurable delay for debouncing\n- Automatic state management\n- Cancellation of previous requests\n- Easy integration with different API call patterns\n\nUsage Example:\n```javascript\n// Basic usage\nconst debouncedSearch = createDebouncedApiCall(fetchData, 300);\n\n// In an input event handler\ninput.addEventListener('input', (e) => {\n  // Debounced API call\n  debouncedSearch(e.target.value);\n\n  // Check loading state\n  if (debouncedSearch.state.isLoading) {\n    showLoadingIndicator();\n  }\n});\n```\n\nThe function is versatile and can be used in various scenarios like:\n- Search input autocomplete\n- Form validation\n- Dynamic data fetching\n- Preventing rapid API calls\n\nPotential Improvements:\n- Add TypeScript types\n- More advanced error handling\n- Configurable retry mechanisms\n- Caching support\n\nThis implementation provides a robust solution for managing debounced API calls with comprehensive state management.",
  "skill_response": "Here's a comprehensive TypeScript implementation of a debounced API call utility with loading state management:\n\n```typescript\ninterface DebouncedFetchOptions<T> {\n  delay?: number;\n  maxWait?: number;\n  onStart?: () => void;\n  onSuccess?: (data: T) => void;\n  onError?: (error: Error) => void;\n}\n\nclass ApiCallManager {\n  private static instance: ApiCallManager;\n  private activeRequests: Map<string, AbortController> = new Map();\n\n  private constructor() {}\n\n  static getInstance(): ApiCallManager {\n    if (!this.instance) {\n      this.instance = new ApiCallManager();\n    }\n    return this.instance;\n  }\n\n  /**\n   * Debounced fetch with advanced control and cancellation\n   * @param url - The API endpoint\n   * @param options - Fetch options and debounce configuration\n   */\n  debouncedFetch = <T = any>(\n    url: string, \n    fetchOptions: RequestInit = {}, \n    debounceOptions: DebouncedFetchOptions<T> = {}\n  ): Promise<T> => {\n    const {\n      delay = 300,\n      maxWait = 1000,\n      onStart,\n      onSuccess,\n      onError\n    } = debounceOptions;\n\n    // Cancel any existing request for this URL\n    this.cancelRequest(url);\n\n    // Create a new abort controller\n    const controller = new AbortController();\n    this.activeRequests.set(url, controller);\n\n    // Trigger loading state\n    onStart?.();\n\n    return new Promise<T>((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        fetch(url, {\n          ...fetchOptions,\n          signal: controller.signal\n        })\n        .then(response => {\n          if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n          }\n          return response.json();\n        })\n        .then(data => {\n          onSuccess?.(data);\n          resolve(data);\n        })\n        .catch(error => {\n          // Ignore abort errors\n          if (error.name !== 'AbortError') {\n            onError?.(error);\n            reject(error);\n          }\n        })\n        .finally(() => {\n          this.activeRequests.delete(url);\n        });\n      }, delay);\n\n      // Optional: Cancel after max wait time\n      const maxWaitTimeout = setTimeout(() => {\n        clearTimeout(timeoutId);\n        controller.abort();\n      }, maxWait);\n    });\n  }\n\n  /**\n   * Cancel an ongoing request for a specific URL\n   * @param url - The URL of the request to cancel\n   */\n  cancelRequest(url: string): void {\n    const controller = this.activeRequests.get(url);\n    if (controller) {\n      controller.abort();\n      this.activeRequests.delete(url);\n    }\n  }\n\n  /**\n   * Cancel all active requests\n   */\n  cancelAllRequests(): void {\n    this.activeRequests.forEach(controller => controller.abort());\n    this.activeRequests.clear();\n  }\n}\n\n// Example usage\nconst apiManager = ApiCallManager.getInstance();\n\n// Search with debounce\nconst searchInput = document.getElementById('search-input');\nsearchInput?.addEventListener('input', (e) => {\n  const query = (e.target as HTMLInputElement).value;\n  \n  apiManager.debouncedFetch(\n    `/api/search?q=${query}`, \n    { method: 'GET' },\n    {\n      delay: 300,\n      onStart: () => {\n        // Show loading spinner\n        document.getElementById('loading')?.classList.remove('hidden');\n      },\n      onSuccess: (data) => {\n        // Update search results\n        document.getElementById('loading')?.classList.add('hidden');\n        renderSearchResults(data);\n      },\n      onError: (error) => {\n        // Handle error\n        document.getElementById('loading')?.classList.add('hidden');\n        showErrorMessage(error);\n      }\n    }\n  );\n});\n```\n\nThis implementation provides several key features:\n\n1. **Debouncing**: Prevents excessive API calls by waiting for a short delay after user input.\n2. **Request Cancellation**: \n   - Cancels previous requests for the same URL\n   - Supports manual cancellation of specific or all requests\n3. **Singleton Pattern**: Ensures a single instance manages all API calls\n4. **Flexible Configuration**:\n   - Configurable delay and max wait time\n   - Optional callbacks for different states (start, success, error)\n5. **Error Handling**: Catches and propagates errors\n6. **TypeScript Support**: Strong typing for type safety\n\nKey Methods:\n- `debouncedFetch()`: Main method for making debounced API calls\n- `cancelRequest()`: Cancel a specific request\n- `cancelAllRequests()`: Cancel all active requests\n\nUsage Example:\n```typescript\n// Basic usage\napiManager.debouncedFetch('/api/data', { method: 'GET' });\n\n// With full options\napiManager.debouncedFetch(\n  '/api/search', \n  { method: 'GET' },\n  {\n    delay: 300,\n    onStart: () => setLoading(true),\n    onSuccess: (data) => {\n      setLoading(false);\n      updateResults(data);\n    },\n    onError: (error) => {\n      setLoading(false);\n      showError(error);\n    }\n  }\n);\n```\n\nThis utility provides a robust solution for managing API calls with debouncing, loading states, and request cancellation.",
  "verdict": "skill",
  "reasoning": "Response A provides a more comprehensive and production-ready solution with several key advantages: 1) Uses a singleton pattern for centralized API call management, 2) Implements proper request cancellation with AbortController for multiple URLs, 3) Provides TypeScript support with proper interfaces and generics, 4) Includes advanced features like maxWait timeout and proper error handling that ignores abort errors, 5) Offers better separation of concerns with clear callback patterns (onStart, onSuccess, onError). Response B, while functional, has a simpler approach that lacks the robustness needed for complex applications - it doesn't handle multiple concurrent requests well, has less sophisticated state management, and provides a more basic implementation. Response A is significantly more practical for real-world usage scenarios.",
  "baseline_tokens": 1440,
  "skill_tokens": 1483,
  "position_a": "skill",
  "position_b": "baseline",
  "judge_model": "claude-sonnet-4-20250514",
  "judged_at": "2026-01-11T18:59:09.222775Z"
}